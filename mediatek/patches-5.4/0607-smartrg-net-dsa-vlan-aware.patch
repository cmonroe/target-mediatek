From ed925edbf84824f863308360cfe5c8cf0114f370 Mon Sep 17 00:00:00 2001
From: Tim Hayes <tim.hayes@smartrg.com>
Date: Thu, 28 Jan 2021 07:37:52 -0800
Subject: [PATCH] OWRT-5930 vlan aware driver and vlan tag aware cpu path

---
 drivers/net/dsa/mt7530.c | 26 +++++++++++++++++++++++++-
 net/dsa/tag_mtk.c        | 33 +++++++++++++++++++++++++--------
 2 files changed, 50 insertions(+), 9 deletions(-)

--- a/drivers/net/dsa/mt7530.c
+++ b/drivers/net/dsa/mt7530.c
@@ -1067,6 +1067,10 @@ unlock_exit:
 }
 
 static int
+mt7530_port_vlan_filtering(struct dsa_switch *ds, int port,
+			   bool vlan_filtering);
+
+static int
 mt753x_cpu_port_enable(struct dsa_switch *ds, int port)
 {
 	struct mt7530_priv *priv = ds->priv;
@@ -1092,9 +1096,15 @@ mt753x_cpu_port_enable(struct dsa_switch
 	mt7530_write(priv, MT7530_PCR_P(port),
 		     PCR_MATRIX(dsa_user_ports(priv->ds)));
 
+	mt7530_port_vlan_filtering(ds,port,1);
+
 	return 0;
 }
 
+static void
+mt7530_port_vlan_add(struct dsa_switch *ds, int port,
+		     const struct switchdev_obj_port_vlan *vlan);
+
 static int
 mt7530_port_enable(struct dsa_switch *ds, int port,
 		   struct phy_device *phy)
@@ -1116,8 +1126,21 @@ mt7530_port_enable(struct dsa_switch *ds
 		   priv->ports[port].pm);
 	mt7530_clear(priv, MT7530_PMCR_P(port), PMCR_LINK_SETTINGS_MASK);
 
+	mt7530_port_vlan_filtering(ds,port,1);
+
 	mutex_unlock(&priv->reg_mutex);
 
+	/* assign default vlan 1 to all ports - especially wan */
+	{
+		struct switchdev_obj_port_vlan _vlan={0};
+		struct switchdev_obj_port_vlan *vlan=&_vlan;
+		vlan->flags |= BRIDGE_VLAN_INFO_UNTAGGED;
+		vlan->flags |= BRIDGE_VLAN_INFO_PVID;
+		vlan->vid_begin=1;
+		vlan->vid_end=1;
+		mt7530_port_vlan_add(ds,port,vlan);
+	}
+
 	return 0;
 }
 
@@ -1565,6 +1588,7 @@ mt7530_port_vlan_add(struct dsa_switch *
 	}
 
 	mutex_unlock(&priv->reg_mutex);
+	pr_debug("%s:%d DSA port %d vlan %d %d pvid %d untagged %d pvid %d\n",__FUNCTION__,__LINE__,port,vlan->vid_begin,vlan->vid_end,pvid,untagged,priv->ports[port].pvid);
 }
 
 static int
@@ -1575,7 +1599,6 @@ mt7530_port_vlan_del(struct dsa_switch *
 	struct mt7530_priv *priv = ds->priv;
 	u16 vid, pvid;
 
-	pr_debug("%s:%d DSA port %d vlan %d %d flags 0x%x \n",__FUNCTION__,__LINE__,port,vlan->vid_begin,vlan->vid_end,vlan->flags);
 	mutex_lock(&priv->reg_mutex);
 
 	pvid = priv->ports[port].pvid;
@@ -1595,6 +1618,7 @@ mt7530_port_vlan_del(struct dsa_switch *
 	priv->ports[port].pvid = pvid;
 
 	mutex_unlock(&priv->reg_mutex);
+	pr_debug("%s:%d DSA port %d pvid %d vlan %d %d flags 0x%x \n",__FUNCTION__,__LINE__,port,pvid,vlan->vid_begin,vlan->vid_end,vlan->flags);
 
 	return 0;
 }
--- a/net/dsa/tag_mtk.c
+++ b/net/dsa/tag_mtk.c
@@ -69,6 +69,8 @@ static struct sk_buff *mtk_tag_rcv(struc
 {
 	int port;
 	__be16 *phdr, hdr;
+	__be16		h_vlan_proto;
+  	__be16		h_vlan_TCI;
 	unsigned char *dest = eth_hdr(skb)->h_dest;
 	bool is_multicast_skb = is_multicast_ether_addr(dest) &&
 				!is_broadcast_ether_addr(dest);
@@ -82,17 +84,32 @@ static struct sk_buff *mtk_tag_rcv(struc
 	 */
 	phdr = (__be16 *)(skb->data - 2);
 	hdr = ntohs(*phdr);
-
-	/* Remove MTK tag and recalculate checksum. */
-	skb_pull_rcsum(skb, MTK_HDR_LEN);
-
-	memmove(skb->data - ETH_HLEN,
-		skb->data - ETH_HLEN - MTK_HDR_LEN,
-		2 * ETH_ALEN);
-
 	/* Get source port information */
 	port = (hdr & MTK_HDR_RECV_SOURCE_PORT_MASK);
 
+	phdr = (__be16 *)(skb->data + 2);
+	h_vlan_proto = ntohs(*phdr);
+	phdr = (__be16 *)(skb->data + 4);
+	h_vlan_TCI = ntohs(*phdr);
+	h_vlan_TCI &= VLAN_VID_MASK;
+
+	/* vlan 1 with vlan_ware interfaces comes in tagged - remove it */
+	if ((h_vlan_proto==ETH_P_8021Q) && (h_vlan_TCI==1)) {
+		/* Remove MTK tag and recalculate checksum. */
+		skb_pull_rcsum(skb, MTK_HDR_LEN+VLAN_HLEN);
+
+		memmove(skb->data - ETH_HLEN,
+			skb->data - ETH_HLEN - MTK_HDR_LEN - VLAN_HLEN,
+			2 * ETH_ALEN);
+	} else {
+		/* Remove MTK tag and recalculate checksum. */
+		skb_pull_rcsum(skb, MTK_HDR_LEN);
+
+		memmove(skb->data - ETH_HLEN,
+			skb->data - ETH_HLEN - MTK_HDR_LEN,
+			2 * ETH_ALEN);
+	}
+
 	skb->dev = dsa_master_find_slave(dev, 0, port);
 	if (!skb->dev)
 		return NULL;
