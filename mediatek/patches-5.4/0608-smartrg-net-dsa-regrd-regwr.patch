From eb3b7c9bbeb339a694ef9a56797cc2d6d8314467 Mon Sep 17 00:00:00 2001
From: Tim Hayes <tim.hayes@smartrg.com>
Date: Mon, 19 Apr 2021 13:56:34 -0700
Subject: [PATCH] OWRT-6126 regrd and regwr added

---
 drivers/net/dsa/mt7530.c | 88 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 88 insertions(+)

diff --git a/drivers/net/dsa/mt7530.c b/drivers/net/dsa/mt7530.c
index 973d6d1..a8f3072 100644
--- a/drivers/net/dsa/mt7530.c
+++ b/drivers/net/dsa/mt7530.c
@@ -18,6 +18,7 @@
 #include <linux/regulator/consumer.h>
 #include <linux/reset.h>
 #include <linux/gpio/consumer.h>
+#include <linux/debugfs.h>
 #include <net/dsa.h>
 
 #include "mt7530.h"
@@ -1191,6 +1192,11 @@ mt7530_stp_state_set(struct dsa_switch *ds, int port, u8 state)
 	}
 
 	mt7530_rmw(priv, MT7530_SSP_P(port), FID_PST_MASK, stp_state);
+	if (0) {
+		u32 val;
+		val=mt7530_read(priv, MT7530_SSP_P(port));
+		printk("%s:%d reg 0x%x val 0x%x \n",__FUNCTION__,__LINE__,MT7530_SSP_P(port),val);
+	}
 }
 
 static int
@@ -2814,6 +2820,81 @@ static const struct of_device_id mt7530_of_match[] = {
 };
 MODULE_DEVICE_TABLE(of, mt7530_of_match);
 
+#define REG_BUF_SIZE 128 
+#define VAL_BUF_SIZE 128 
+static char regbuf[REG_BUF_SIZE]={0}; 
+static char valbuf[VAL_BUF_SIZE]={0}; 
+static char cmd[24]={"NULL"};
+static u32 offset=0;
+static u64 val=0;
+struct mt7530_priv *regdev;
+static u16 done=0;
+/*
+regrd  <reg> 
+regwr  <reg> <val> 
+*/
+
+static ssize_t mtk_common_reg_read(struct file *file, char __user *ubuf, size_t len, loff_t *ppos)
+{
+	if( strcmp(cmd,"regrd")==0 ) {
+		if ((regdev!=NULL) && (done==0)) {
+			done=1;
+			val=0;
+			val=mt7530_read(regdev,offset);
+			
+		}
+	}
+	snprintf(valbuf,VAL_BUF_SIZE, "0x%08x\n",(u32)val);
+	return (simple_read_from_buffer(ubuf, len, ppos, valbuf, strlen(valbuf)));
+}
+
+static ssize_t mtk_common_reg_write(struct file *file, const char __user *ubuf, size_t len, loff_t *ppos)
+{
+	int bytes = 0;
+	int n=0;
+
+	if (len >= REG_BUF_SIZE) {
+		return -ENOMEM;
+	}
+
+	memset(valbuf,0,VAL_BUF_SIZE);
+	memset(regbuf,0,REG_BUF_SIZE);
+	bytes = simple_write_to_buffer(regbuf,sizeof(regbuf) - 1, ppos, ubuf, len);
+	regbuf[sizeof(regbuf) - 1] = '\0';
+
+	n=sscanf(regbuf,"%s",&cmd);
+	if (n != 1) {
+		return -EFAULT;
+	}
+	if( strcmp(cmd,"regrd")==0 ) {
+		n=sscanf(regbuf,"%s %x ",&cmd,&offset);
+		
+	} else if( strcmp(cmd,"regwr")==0 ) {
+		n=sscanf(regbuf,"%s %x %x ",&cmd,&offset,&val);
+	} else {
+		return -EFAULT;
+	}
+
+	done=0;
+
+	if( strcmp(cmd,"regwr")==0 ) {
+		if ((regdev!=NULL) && (done==0)) {
+			done=1;
+			mt7530_write(regdev,offset,(u32)val);
+		}
+	}
+
+	return (len);
+}
+
+static const struct file_operations mtk_common_reg_ops = {
+	.owner  = THIS_MODULE,
+	.open   = simple_open,
+	.write  = mtk_common_reg_write,
+	.read   = mtk_common_reg_read,
+	.llseek = default_llseek,
+};
+
 static int
 mt7530_probe(struct mdio_device *mdiodev)
 {
@@ -2898,6 +2979,13 @@ mt7530_probe(struct mdio_device *mdiodev)
 	mutex_init(&priv->mib_lock);
 	INIT_DELAYED_WORK(&priv->mib_work, mt7530_mib_work_func);
 
+	{
+	static struct dentry *debugfs_dir = NULL;
+	debugfs_dir = debugfs_create_dir("mtkreg", NULL);
+	debugfs_create_file("regrdwr",(S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH), debugfs_dir, NULL, &mtk_common_reg_ops);
+	regdev=priv;
+	}
+
 	return dsa_register_switch(priv->ds);
 }
 
-- 
2.29.0

