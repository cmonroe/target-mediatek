--- a/net/bridge/br_switchdev.c
+++ b/net/bridge/br_switchdev.c
@@ -874,3 +874,42 @@ int br_switchdev_port_replay(struct net_
 {
 	return nbp_switchdev_sync_objs(p, ctx, atomic_nb, blocking_nb, extack);
 }
+
+void br_switchdev_add_vlanport( struct net_device *dev,
+			     struct netdev_phys_item_id ppid )
+{
+	struct net_bridge_port *p = br_port_get_rtnl(dev);
+	
+	if ( !p )
+		return;
+
+	if (p->offload_count) {
+		p->offload_count++;
+		return;
+	}
+
+	p->ppid = ppid;
+	p->offload_count = 1;
+
+	nbp_switchdev_hwdom_set(p);
+}
+
+void br_switchdev_del_vlanport( struct net_device *dev )
+{
+	struct net_bridge_port *p = br_port_get_rtnl(dev);
+
+	if ( !p )
+		return;
+
+	if (WARN_ON(!p->offload_count))
+		return;
+
+	p->offload_count--;
+
+	if (p->offload_count)
+		return;
+
+	if (p->hwdom)
+		nbp_switchdev_hwdom_put(p);
+}
+
--- a/net/bridge/br_sysfs_if.c
+++ b/net/bridge/br_sysfs_if.c
@@ -81,6 +81,31 @@ static int store_flag(struct net_bridge_
 	return 0;
 }
 
+// Show brport ppid and hwdom
+//
+static ssize_t show_phys_id(struct net_bridge_port *p, char *buf)
+{
+        if (p->ppid.id_len)
+		return sprintf(buf, "%*phN\n", p->ppid.id_len, p->ppid.id);
+
+        return 0;
+}
+
+static BRPORT_ATTR(phys_id, 0444, show_phys_id, NULL);
+
+
+static ssize_t show_hwdom(struct net_bridge_port *p, char *buf)
+{
+        return sprintf(buf, "%d\n", p->hwdom);
+}
+static int store_hwdom(struct net_bridge_port *p, unsigned long v)
+{
+        p->hwdom = v;
+        return 0;
+}
+
+static BRPORT_ATTR(hwdom, 0644, show_hwdom, store_hwdom);
+
 static ssize_t show_path_cost(struct net_bridge_port *p, char *buf)
 {
 	return sprintf(buf, "%d\n", p->path_cost);
@@ -261,6 +286,8 @@ BRPORT_ATTR_FLAG(multicast_to_unicast, B
 #endif
 
 static const struct brport_attribute *brport_attrs[] = {
+	&brport_attr_hwdom,
+	&brport_attr_phys_id,
 	&brport_attr_path_cost,
 	&brport_attr_priority,
 	&brport_attr_port_id,
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@ -3319,6 +3319,11 @@ static int dsa_master_changeupper(struct
 	return err;
 }
 
+void br_switchdev_add_vlanport( struct net_device *dev,
+			     struct netdev_phys_item_id ppid );
+void br_switchdev_del_vlanport( struct net_device *dev );
+
+
 static int dsa_slave_netdevice_event(struct notifier_block *nb,
 				     unsigned long event, void *ptr)
 {
@@ -3353,6 +3358,31 @@ static int dsa_slave_netdevice_event(str
 		if (notifier_to_errno(err))
 			return err;
 
+		if ( is_vlan_dev(dev) )
+		{
+			struct net_device *parent_dev = vlan_dev_real_dev(dev);
+			if ( dsa_slave_dev_check(parent_dev) )
+			{
+				struct netdev_notifier_changeupper_info *info = ptr;
+				struct netdev_phys_item_id ppid;
+
+				// Get the PPID of parent DSA port
+				if ( !dev_get_port_parent_id(parent_dev, &ppid, false) )
+				{
+					printk("Setting brport hwdom on vlan device %s due to NETDEV_CHANGEUPPER linking %d", dev->name, info->linking );
+
+					if ( info->linking)
+					{
+						br_switchdev_add_vlanport( dev, ppid );
+					}
+					else
+					{
+						br_switchdev_del_vlanport( dev );
+					}
+				}
+			}
+		}
+
 		break;
 	}
 	case NETDEV_CHANGEUPPER: {
