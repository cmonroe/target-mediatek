From 3998f45bfea096436466b29aeef194903f9605a8 Mon Sep 17 00:00:00 2001
From: Tim Hayes <tim.hayes@smartrg.com>
Date: Wed, 7 Oct 2020 07:53:03 -0700
Subject: [PATCH] OWRT-5535 get_dev_stats added

---
 drivers/net/dsa/mt7530.c | 192 +++++++++++++++++++++++++++++++++++++----------
 drivers/net/dsa/mt7530.h |  35 ++++++++-
 2 files changed, 186 insertions(+), 41 deletions(-)

--- a/drivers/net/dsa/mt7530.c
+++ b/drivers/net/dsa/mt7530.c
@@ -31,47 +31,47 @@ static struct mt753x_pcs *pcs_to_mt753x_
 
 /* String, offset, and register size in bytes if different from 4 bytes */
 static const struct mt7530_mib_desc mt7530_mib[] = {
-	MIB_DESC(1, 0x00, "TxDrop"),
-	MIB_DESC(1, 0x04, "TxCrcErr"),
-	MIB_DESC(1, 0x08, "TxUnicast"),
-	MIB_DESC(1, 0x0c, "TxMulticast"),
-	MIB_DESC(1, 0x10, "TxBroadcast"),
-	MIB_DESC(1, 0x14, "TxCollision"),
-	MIB_DESC(1, 0x18, "TxSingleCollision"),
-	MIB_DESC(1, 0x1c, "TxMultipleCollision"),
-	MIB_DESC(1, 0x20, "TxDeferred"),
-	MIB_DESC(1, 0x24, "TxLateCollision"),
-	MIB_DESC(1, 0x28, "TxExcessiveCollistion"),
-	MIB_DESC(1, 0x2c, "TxPause"),
-	MIB_DESC(1, 0x30, "TxPktSz64"),
-	MIB_DESC(1, 0x34, "TxPktSz65To127"),
-	MIB_DESC(1, 0x38, "TxPktSz128To255"),
-	MIB_DESC(1, 0x3c, "TxPktSz256To511"),
-	MIB_DESC(1, 0x40, "TxPktSz512To1023"),
-	MIB_DESC(1, 0x44, "Tx1024ToMax"),
-	MIB_DESC(2, 0x48, "TxBytes"),
-	MIB_DESC(1, 0x60, "RxDrop"),
-	MIB_DESC(1, 0x64, "RxFiltering"),
-	MIB_DESC(1, 0x68, "RxUnicast"),
-	MIB_DESC(1, 0x6c, "RxMulticast"),
-	MIB_DESC(1, 0x70, "RxBroadcast"),
-	MIB_DESC(1, 0x74, "RxAlignErr"),
-	MIB_DESC(1, 0x78, "RxCrcErr"),
-	MIB_DESC(1, 0x7c, "RxUnderSizeErr"),
-	MIB_DESC(1, 0x80, "RxFragErr"),
-	MIB_DESC(1, 0x84, "RxOverSzErr"),
-	MIB_DESC(1, 0x88, "RxJabberErr"),
-	MIB_DESC(1, 0x8c, "RxPause"),
-	MIB_DESC(1, 0x90, "RxPktSz64"),
-	MIB_DESC(1, 0x94, "RxPktSz65To127"),
-	MIB_DESC(1, 0x98, "RxPktSz128To255"),
-	MIB_DESC(1, 0x9c, "RxPktSz256To511"),
-	MIB_DESC(1, 0xa0, "RxPktSz512To1023"),
-	MIB_DESC(1, 0xa4, "RxPktSz1024ToMax"),
-	MIB_DESC(2, 0xa8, "RxBytes"),
-	MIB_DESC(1, 0xb0, "RxCtrlDrop"),
-	MIB_DESC(1, 0xb4, "RxIngressDrop"),
-	MIB_DESC(1, 0xb8, "RxArlDrop"),
+	MIB_DESC(1, 0x00,MTXD, "TxDrop"),
+	MIB_DESC(1, 0x04,MTXE, "TxCrcErr"),
+	MIB_DESC(1, 0x08,MTXP, "TxUnicast"),
+	MIB_DESC(1, 0x0c,MTXM, "TxMulticast"),
+	MIB_DESC(1, 0x10,MTXR, "TxBroadcast"),
+	MIB_DESC(1, 0x14,MCOL, "TxCollision"),
+	MIB_DESC(1, 0x18,MCOL, "TxSingleCollision"),
+	MIB_DESC(1, 0x1c,MCOL, "TxMultipleCollision"),
+	MIB_DESC(1, 0x20,MNOM, "TxDeferred"),
+	MIB_DESC(1, 0x24,MCOL, "TxLateCollision"),
+	MIB_DESC(1, 0x28,MCOL, "TxExcessiveCollistion"),
+	MIB_DESC(1, 0x2c,MNOM, "TxPause"),
+	MIB_DESC(1, 0x30,MNOM, "TxPktSz64"),
+	MIB_DESC(1, 0x34,MNOM, "TxPktSz65To127"),
+	MIB_DESC(1, 0x38,MNOM, "TxPktSz128To255"),
+	MIB_DESC(1, 0x3c,MNOM, "TxPktSz256To511"),
+	MIB_DESC(1, 0x40,MNOM, "TxPktSz512To1023"),
+	MIB_DESC(1, 0x44,MNOM, "Tx1024ToMax"),
+	MIB_DESC(2, 0x48,MTXB, "TxBytes"),
+	MIB_DESC(1, 0x60,MRXD, "RxDrop"),
+	MIB_DESC(1, 0x64,MRXD, "RxFiltering"),
+	MIB_DESC(1, 0x68,MRXP, "RxUnicast"),
+	MIB_DESC(1, 0x6c,MRXM, "RxMulticast"),
+	MIB_DESC(1, 0x70,MRXR, "RxBroadcast"),
+	MIB_DESC(1, 0x74,MRXE, "RxAlignErr"),
+	MIB_DESC(1, 0x78,MCRC, "RxCrcErr"),
+	MIB_DESC(1, 0x7c,MRLE, "RxUnderSizeErr"),
+	MIB_DESC(1, 0x80,MRXE, "RxFragErr"),
+	MIB_DESC(1, 0x84,MRXE, "RxOverSzErr"),
+	MIB_DESC(1, 0x88,MRXE, "RxJabberErr"),
+	MIB_DESC(1, 0x8c,MNOM, "RxPause"),
+	MIB_DESC(1, 0x90,MNOM, "RxPktSz64"),
+	MIB_DESC(1, 0x94,MNOM, "RxPktSz65To127"),
+	MIB_DESC(1, 0x98,MNOM, "RxPktSz128To255"),
+	MIB_DESC(1, 0x9c,MNOM, "RxPktSz256To511"),
+	MIB_DESC(1, 0xa0,MNOM, "RxPktSz512To1023"),
+	MIB_DESC(1, 0xa4,MNOM, "RxPktSz1024ToMax"),
+	MIB_DESC(2, 0xa8,MRXB, "RxBytes"),
+	MIB_DESC(1, 0xb0,MRXD, "RxCtrlDrop"),
+	MIB_DESC(1, 0xb4,MRXD, "RxIngressDrop"),
+	MIB_DESC(1, 0xb8,MRXD, "RxArlDrop"),
 };
 
 static void
@@ -809,6 +809,121 @@ mt7530_get_ethtool_stats(struct dsa_swit
 	}
 }
 
+static void
+mt7530_mib_fetch_port_stat(struct mt7530_priv *priv, int port)
+{
+	u32 reg, i;
+	u32 num_mibs = ARRAY_SIZE(mt7530_mib);
+	struct rtnl_link_stats64 *storage;
+	u64 hi;
+
+	storage=&priv->stats[port];
+	memset(storage, 0,sizeof(*storage));
+
+	for (i = 0; i < num_mibs; i++) {
+		const struct mt7530_mib_desc *mib;
+		u64 val=0;
+		mib = &mt7530_mib[i];
+		reg = MT7530_PORT_MIB_COUNTER(port) + mib->offset;
+		val = mt7530_read(priv, reg);
+		if (mib->size == 2) {
+			hi = mt7530_read(priv, reg + 4);
+			val |= hi << 32;
+		}
+		switch(mib->map) {
+				case MTXB:
+				storage->tx_bytes += val;
+				break;
+				case MTXD:
+				storage->tx_dropped += val;
+				break;
+				case MTXP:
+				storage->tx_packets += val;
+				break;
+				case MTXR:
+				storage->tx_packets += val;
+				break;
+				case MTXM:
+				storage->multicast += val;
+				storage->tx_packets += val;
+				break;
+				case MTXE:
+				storage->tx_errors += val;
+				break;
+				case MCOL:
+				storage->collisions += val;
+				break;
+				case MRXB:
+				storage->rx_bytes += val;
+				break;
+				case MRXD:
+				storage->rx_dropped += val;
+				break;
+				case MRXP:
+				storage->rx_packets += val;
+				break;
+				case MRXR:
+				storage->rx_packets += val;
+				break;
+				case MRXM:
+				storage->multicast += val;
+				storage->rx_packets += val;
+				break;
+				case MRXE:
+				storage->rx_errors += val;
+				break;
+				case MRLE:
+				storage->rx_errors += val;
+				storage->rx_length_errors += val;
+				break;
+				case MCRC:
+				storage->rx_crc_errors += val;
+				break;
+				case MRME:
+				storage->rx_missed_errors += val;
+				break;
+		}
+	}
+}
+
+static void
+mt7530_mib_work_func(struct work_struct *work)
+{
+	struct mt7530_priv *priv;
+	int port;
+
+	priv = container_of(work, struct mt7530_priv, mib_work.work);
+
+	for (port = 0; port < MT7530_NUM_PORTS; port++) {
+		mutex_lock(&priv->mib_lock);
+		mt7530_mib_fetch_port_stat(priv,port);
+		mutex_unlock(&priv->mib_lock);
+	}
+
+	schedule_delayed_work(&priv->mib_work,
+			      msecs_to_jiffies(MT7530_MIB_WORK_DELAY));
+}
+
+void mt7530_get_stats64(struct dsa_switch *ds, int port,struct rtnl_link_stats64 *stats)
+{
+	static int dev_stats_started=0;
+	struct mt7530_priv *priv = ds->priv;
+	
+	if (stats!=NULL) {
+		mutex_lock(&priv->mib_lock);
+		memcpy(stats,&priv->stats[port],sizeof(struct rtnl_link_stats64));
+		mutex_unlock(&priv->mib_lock);
+	} else {
+		dev_err(ds->dev, "NULL stats64 pointer\n");
+	}
+	if(dev_stats_started==0) {
+		dev_stats_started=1;
+		schedule_delayed_work(&priv->mib_work,
+		      msecs_to_jiffies(MT7530_MIB_WORK_DELAY));
+		
+	}
+}
+
 static int
 mt7530_get_sset_count(struct dsa_switch *ds, int port, int sset)
 {
@@ -3136,6 +3251,7 @@ const struct dsa_switch_ops mt7530_switc
 	.preferred_default_local_cpu_port = mt753x_preferred_default_local_cpu_port,
 	.get_strings		= mt7530_get_strings,
 	.get_ethtool_stats	= mt7530_get_ethtool_stats,
+	.get_stats64	= mt7530_get_stats64,
 	.get_sset_count		= mt7530_get_sset_count,
 	.set_ageing_time	= mt7530_set_ageing_time,
 	.port_enable		= mt7530_port_enable,
@@ -3245,6 +3361,9 @@ mt7530_probe_common(struct mt7530_priv *
 	mutex_init(&priv->reg_mutex);
 	dev_set_drvdata(dev, priv);
 
+	mutex_init(&priv->mib_lock);
+	INIT_DELAYED_WORK(&priv->mib_work, mt7530_mib_work_func);
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(mt7530_probe_common);
@@ -3252,6 +3371,8 @@ EXPORT_SYMBOL_GPL(mt7530_probe_common);
 void
 mt7530_remove_common(struct mt7530_priv *priv)
 {
+	cancel_delayed_work_sync(&priv->mib_work);
+
 	if (priv->irq)
 		mt7530_free_irq(priv);
 
--- a/drivers/net/dsa/mt7530.h
+++ b/drivers/net/dsa/mt7530.h
@@ -690,19 +690,51 @@ enum mt7531_xtal_fsel {
 #define  REG_GSWCK_EN			BIT(0)
 #define  REG_TRGMIICK_EN		BIT(1)
 
-#define MIB_DESC(_s, _o, _n)	\
+#define MIB_DESC(_s, _o,_m, _n)	\
 	{			\
 		.size = (_s),	\
 		.offset = (_o),	\
+		.map = (_m),	\
 		.name = (_n),	\
 	}
 
 struct mt7530_mib_desc {
 	unsigned int size;
 	unsigned int offset;
+	u32 map;
 	const char *name;
 };
 
+/* hw specific mib to Linux Ethernet counter mappings (map element) */
+#define MNOM 0	// no mapping		
+#define MRXP 1	// rx_packets		
+#define MTXP 2	// tx_packets		
+#define MRXB 3	// rx_bytes			
+#define MTXB 4	// tx_bytes			
+#define MRXE 5	// rx_errors		
+#define MTXE 6	// tx_errors		
+#define MRXD 7	// rx_dropped		
+#define MTXD 8	// tx_dropped		
+#define MTXM 9	// multicast		
+#define MRXM 10	// multicast		
+#define MCOL 11	// collisions		
+#define MRLE 12 	// rx_length_errors	
+#define MROE 13 	// rx_over_errors		
+#define MCRC 14	// rx_crc_errors		
+#define MRFE 15	// rx_frame_errors		
+#define MRIE 16	// rx_fifo_errors		
+#define MRME 17	// rx_missed_errors	
+#define MTAE 18	// tx_aborted_errors	
+#define MTCE 19 	// tx_carrier_errors	
+#define MTFE 20	// tx_fifo_errors		
+#define MTHE 21	// tx_heartbeat_errors	
+#define MTWE 22	// tx_window_errors	
+#define MRCM 23	// rx_compressed
+#define MTCM 24	// tx_compressed
+#define MRXR 25	// rx broadcast			
+#define MTXR 26	// tx_broadcast			
+#define MT7530_MIB_WORK_DELAY	1000 /* msecs */
+
 struct mt7530_fdb {
 	u16 vid;
 	u8 port_mask;
@@ -825,6 +857,9 @@ struct mt7530_priv {
 	int (*create_sgmii)(struct mt7530_priv *priv);
 	u8 active_cpu_ports;
 	struct mdio_device *mdiodev;
+	struct mutex mib_lock;
+	struct delayed_work mib_work;
+	struct rtnl_link_stats64 stats[MT7530_NUM_PORTS];
 };
 
 struct mt7530_hw_vlan_entry {
