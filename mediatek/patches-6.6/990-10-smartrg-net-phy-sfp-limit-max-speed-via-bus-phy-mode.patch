--- a/drivers/net/phy/sfp-bus.c
+++ b/drivers/net/phy/sfp-bus.c
@@ -340,7 +340,7 @@ void sfp_parse_support(struct sfp_bus *b
 	phylink_set(modes, Asym_Pause);
 
 	if (bus->sfp_quirk && bus->sfp_quirk->modes)
-		bus->sfp_quirk->modes(id, modes, interfaces);
+		bus->sfp_quirk->modes(bus->sfp, id, modes, interfaces);
 
 	linkmode_or(support, support, modes);
 }
--- a/drivers/net/phy/sfp.h
+++ b/drivers/net/phy/sfp.h
@@ -9,8 +9,8 @@ struct sfp;
 struct sfp_quirk {
 	const char *vendor;
 	const char *part;
-	void (*modes)(const struct sfp_eeprom_id *id, unsigned long *modes,
-		      unsigned long *interfaces);
+	void (*modes)(struct sfp *sfp,  const struct sfp_eeprom_id *id,
+		      unsigned long *modes, unsigned long *interfaces);
 	void (*fixup)(struct sfp *sfp);
 };
 
--- a/drivers/net/phy/sfp.c
+++ b/drivers/net/phy/sfp.c
@@ -1,6 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0
 #include <linux/debugfs.h>
 #include <linux/delay.h>
+#include <linux/device.h>
 #include <linux/gpio/consumer.h>
 #include <linux/hwmon.h>
 #include <linux/i2c.h>
@@ -10,8 +11,10 @@
 #include <linux/module.h>
 #include <linux/mutex.h>
 #include <linux/of.h>
+#include <linux/of_net.h>
 #include <linux/phy.h>
 #include <linux/platform_device.h>
+#include <linux/property.h>
 #include <linux/rtnetlink.h>
 #include <linux/slab.h>
 #include <linux/workqueue.h>
@@ -396,7 +399,8 @@ static void sfp_fixup_rollball_cc(struct
 	sfp->id.base.extended_cc = SFF8024_ECC_10GBASE_T_SFI;
 }
 
-static void sfp_quirk_2500basex(const struct sfp_eeprom_id *id,
+static void sfp_quirk_2500basex(struct sfp *sfp,
+				const struct sfp_eeprom_id *id,
 				unsigned long *modes,
 				unsigned long *interfaces)
 {
@@ -404,24 +408,27 @@ static void sfp_quirk_2500basex(const st
 	__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);
 }
 
-static void sfp_quirk_disable_autoneg(const struct sfp_eeprom_id *id,
+static void sfp_quirk_disable_autoneg(struct sfp *sfp,
+				      const struct sfp_eeprom_id *id,
 				      unsigned long *modes,
 				      unsigned long *interfaces)
 {
 	linkmode_clear_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, modes);
 }
 
-static void sfp_quirk_oem_2_5g(const struct sfp_eeprom_id *id,
+static void sfp_quirk_oem_2_5g(struct sfp *sfp,
+			       const struct sfp_eeprom_id *id,
 			       unsigned long *modes,
 			       unsigned long *interfaces)
 {
 	/* Copper 2.5G SFP */
 	linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, modes);
 	__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);
-	sfp_quirk_disable_autoneg(id, modes, interfaces);
+	sfp_quirk_disable_autoneg(sfp, id, modes, interfaces);
 }
 
-static void sfp_quirk_ubnt_uf_instant(const struct sfp_eeprom_id *id,
+static void sfp_quirk_ubnt_uf_instant(struct sfp *sfp,
+				      const struct sfp_eeprom_id *id,
 				      unsigned long *modes,
 				      unsigned long *interfaces)
 {
@@ -438,6 +445,78 @@ static void sfp_quirk_ubnt_uf_instant(co
 #define SFP_QUIRK_M(_v, _p, _m) SFP_QUIRK(_v, _p, _m, NULL)
 #define SFP_QUIRK_F(_v, _p, _f) SFP_QUIRK(_v, _p, NULL, _f)
 
+static void sfp_quirk_phy_mode(struct sfp *sfp,
+				const struct sfp_eeprom_id *id, unsigned long *modes)
+{
+	int speed;
+	struct device_node *mac_np, *sfp_np;
+	phy_interface_t interface = PHY_INTERFACE_MODE_NA;
+
+	dev_warn(sfp->dev, "%s: entry modes 0x%016lx", __FUNCTION__, *modes);
+
+	if (!sfp->dev->of_node) {
+		dev_warn(sfp->dev, "%s: OF node is empty, bailing!", __FUNCTION__);
+		return;
+	}
+
+	/**
+	 * scan thru each node with sfp property and find the
+	 * one which has our current sfp bus bound to it.
+	 */
+	for_each_node_with_property(mac_np, "sfp") {
+		sfp_np = of_parse_phandle(mac_np, "sfp", 0);
+		if (sfp_np && (sfp->dev->of_node == sfp_np)) {
+			if (of_get_phy_mode(mac_np, &interface) == 0) {
+				of_node_put(sfp_np);
+				break;
+			}
+		}
+		of_node_put(sfp_np);
+	}
+
+	if (interface == PHY_INTERFACE_MODE_NA) {
+		dev_warn(sfp->dev, "mac interface mode not found");
+		return;
+	}
+
+	switch (interface) {
+		case PHY_INTERFACE_MODE_2500BASEX:
+			linkmode_zero(modes);
+			//linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT, modes);
+			linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT, modes);
+			speed = 2500;
+			break;
+		case PHY_INTERFACE_MODE_5GBASER:
+			/* do nothing for now */
+			speed = 5000;
+			break;
+		case PHY_INTERFACE_MODE_USXGMII:
+		case PHY_INTERFACE_MODE_10GBASER:
+		case PHY_INTERFACE_MODE_10GKR:
+			/* do nothing for now */
+			speed = 10000;
+			break;
+		default:
+			linkmode_zero(modes);
+			linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT, modes);
+			speed = 1000;
+			break;
+
+	}
+
+	dev_warn(sfp->dev, "%s: set speed: %d based on bus phy-mode: %s",
+			__FUNCTION__, speed, phy_modes(interface));
+	dev_warn(sfp->dev, "%s: exit modes 0x%016lx", __FUNCTION__, *modes);
+}
+
+// default quirk to use when unknown 10G devices are found
+static const struct sfp_quirk sfp_quirk_default_phy_mode = {
+	.vendor = "ADTRAN",
+	.part = "DEFAULT-PHY-MODE",
+	.modes = sfp_quirk_phy_mode,
+	.fixup = NULL,
+};
+
 static const struct sfp_quirk sfp_quirks[] = {
 	// Alcatel Lucent G-010S-P can operate at 2500base-X, but incorrectly
 	// report 2500MBd NRZ in their EEPROM
@@ -2333,6 +2412,24 @@ static int sfp_sm_mod_probe(struct sfp *
 		sfp->mdio_protocol = MDIO_I2C_NONE;
 
 	sfp->quirk = sfp_lookup_quirk(&id);
+	if (!sfp->quirk) {
+		unsigned int nom_rate = id.base.br_nominal*100;
+
+		/* If no quirk handler found and nominal bit rate > 2.5G + 28%
+		 * Modules supporting 2500BASE-X. Note that some
+		 * modules use 2500Mbaud rather than 3100 or 3200Mbaud for
+		 * 2500BASE-X, so we allow some slack here.
+		 */
+		if (nom_rate > 3200) {
+			dev_info(sfp->dev, "no quirk and br_nom > 3200, setting default based on bus phy-mode");
+			sfp->quirk = &sfp_quirk_default_phy_mode;
+		} else {
+			dev_info(sfp->dev, "no quirk and br_nom <= 3200, no fixups or modes applied");
+		}
+	} else {
+		dev_info(sfp->dev, "found quirk handler for vendor[%s] part[%s] applied",
+			sfp->quirk->vendor, sfp->quirk->part);
+	}
 
 	mutex_lock(&sfp->st_mutex);
 	/* Initialise state bits to use from hardware */
