From 4eb618c9fba29f728d033c96fb3d73cd2c833f7f Mon Sep 17 00:00:00 2001
From: LGA1150 <dqfext@gmail.com>
Date: Mon, 17 May 2021 18:00:42 +0200
Subject: [PATCH] net: dsa: mt7530: allow multicpu

---
 drivers/net/dsa/mt7530.c | 80 ++++++++++++++++++++++++++--------------
 1 file changed, 52 insertions(+), 28 deletions(-)

Index: linux-5.15.45/drivers/net/dsa/mt7530.c
===================================================================
--- linux-5.15.45.orig/drivers/net/dsa/mt7530.c
+++ linux-5.15.45/drivers/net/dsa/mt7530.c
@@ -1133,6 +1133,9 @@ mt753x_cpu_port_enable(struct dsa_switch
 	mt7530_rmw(priv, MT7530_MFC, BC_FFP_MASK | UNM_FFP_MASK | UNU_FFP_MASK,
 		   BC_FFP(BIT(port)) | UNM_FFP(BIT(port)) | UNU_FFP(BIT(port)));
 
+	/* Disable auto learning on the cpu port */
+	mt7530_set(priv, MT7530_PSC_P(port), SA_DIS);
+
 	/* Set CPU port number */
 	if (priv->id == ID_MT7621)
 		mt7530_rmw(priv, MT7530_MFC, CPU_MASK, CPU_EN | CPU_PORT(port));
@@ -1164,7 +1167,7 @@ mt7530_port_enable(struct dsa_switch *ds
 	 * restore the port matrix if the port is the member of a certain
 	 * bridge.
 	 */
-	priv->ports[port].pm |= PCR_MATRIX(BIT(MT7530_CPU_PORT));
+	priv->ports[port].pm |= PCR_MATRIX(BIT(dsa_upstream_port(ds, port)));
 	priv->ports[port].enable = true;
 	mt7530_rmw(priv, MT7530_PCR_P(port), PCR_MATRIX_MASK,
 		   priv->ports[port].pm);
@@ -1314,7 +1317,7 @@ mt7530_port_bridge_join(struct dsa_switc
 			struct net_device *bridge)
 {
 	struct mt7530_priv *priv = ds->priv;
-	u32 port_bitmap = BIT(MT7530_CPU_PORT);
+	u32 port_bitmap = BIT(dsa_upstream_port(ds, port));
 	int i;
 
 	mutex_lock(&priv->reg_mutex);
@@ -1388,10 +1391,14 @@ mt7530_port_set_vlan_unaware(struct dsa_
 	 * the CPU port get out of VLAN filtering mode.
 	 */
 	if (all_user_ports_removed) {
-		mt7530_write(priv, MT7530_PCR_P(MT7530_CPU_PORT),
-			     PCR_MATRIX(dsa_user_ports(priv->ds)));
-		mt7530_write(priv, MT7530_PVC_P(MT7530_CPU_PORT), PORT_SPEC_TAG
-			     | PVC_EG_TAG(MT7530_VLAN_EG_CONSISTENT));
+		for (i = 0; i < MT7530_NUM_PORTS; i++) {
+			if (dsa_is_cpu_port(ds, i)) {
+				mt7530_write(priv, MT7530_PCR_P(i),
+					     PCR_MATRIX(dsa_user_ports(priv->ds)));
+				mt7530_write(priv, MT7530_PVC_P(i), PORT_SPEC_TAG |
+					     PVC_EG_TAG(MT7530_VLAN_EG_CONSISTENT));
+			}
+		}
 	}
 	pr_debug("%s DSA port %d \n",__FUNCTION__,port);
 }
@@ -1454,8 +1461,8 @@ mt7530_port_bridge_leave(struct dsa_swit
 	 */
 	if (priv->ports[port].enable)
 		mt7530_rmw(priv, MT7530_PCR_P(port), PCR_MATRIX_MASK,
-			   PCR_MATRIX(BIT(MT7530_CPU_PORT)));
-	priv->ports[port].pm = PCR_MATRIX(BIT(MT7530_CPU_PORT));
+			   PCR_MATRIX(BIT(dsa_upstream_port(ds, port))));
+	priv->ports[port].pm = PCR_MATRIX(BIT(dsa_upstream_port(ds, port)));
 
 	/* When a port is removed from the bridge, the port would be set up
 	 * back to the default as is at initial boot which is a VLAN-unaware
@@ -1474,7 +1481,9 @@ mt7530_port_fdb_add(struct dsa_switch *d
 {
 	struct mt7530_priv *priv = ds->priv;
 	int ret;
-	u8 port_mask = BIT(port);
+	u8 cpu_port_mask = dsa_cpu_ports(ds);
+	u8 port_mask = cpu_port_mask & BIT(port) ?
+		       cpu_port_mask : BIT(port);
 
 	mutex_lock(&priv->reg_mutex);
 	mt7530_fdb_write(priv, vid, port_mask, addr, -1, STATIC_ENT);
@@ -1492,7 +1501,9 @@ mt7530_port_fdb_del(struct dsa_switch *d
 {
 	struct mt7530_priv *priv = ds->priv;
 	int ret;
-	u8 port_mask = BIT(port);
+	u8 cpu_port_mask = dsa_cpu_ports(ds);
+	u8 port_mask = cpu_port_mask & BIT(port) ?
+		       cpu_port_mask : BIT(port);
 
 	mutex_lock(&priv->reg_mutex);
 	mt7530_fdb_write(priv, vid, port_mask, addr, -1, STATIC_EMP);
@@ -1583,6 +1594,7 @@ mt7530_port_mdb_add(struct dsa_switch *d
 	struct mt7530_priv *priv = ds->priv;
 	const u8 *addr = mdb->addr;
 	u16 vid = mdb->vid;
+	u8 cpu_port_mask = dsa_cpu_ports(ds);
 	u8 port_mask = 0;
 	int ret;
 
@@ -1593,7 +1605,8 @@ mt7530_port_mdb_add(struct dsa_switch *d
 		port_mask = (mt7530_read(priv, MT7530_ATRD) >> PORT_MAP)
 			    & PORT_MAP_MASK;
 
-	port_mask |= BIT(port);
+	port_mask |= cpu_port_mask & BIT(port) ?
+		     cpu_port_mask : BIT(port);
 	mt7530_fdb_write(priv, vid, port_mask, addr, -1, STATIC_ENT);
 	ret = mt7530_fdb_cmd(priv, MT7530_FDB_WRITE, NULL);
 
@@ -1609,6 +1622,7 @@ mt7530_port_mdb_del(struct dsa_switch *d
 	struct mt7530_priv *priv = ds->priv;
 	const u8 *addr = mdb->addr;
 	u16 vid = mdb->vid;
+	u8 cpu_port_mask = dsa_cpu_ports(ds);
 	u8 port_mask = 0;
 	int ret;
 
@@ -1619,7 +1633,8 @@ mt7530_port_mdb_del(struct dsa_switch *d
 		port_mask = (mt7530_read(priv, MT7530_ATRD) >> PORT_MAP)
 			    & PORT_MAP_MASK;
 
-	port_mask &= ~BIT(port);
+	port_mask &= cpu_port_mask & BIT(port) ?
+		     ~cpu_port_mask : ~BIT(port);
 	mt7530_fdb_write(priv, vid, port_mask, addr, -1,
 			 port_mask ? STATIC_ENT : STATIC_EMP);
 	ret = mt7530_fdb_cmd(priv, MT7530_FDB_WRITE, NULL);
@@ -1667,8 +1682,12 @@ mt7530_port_vlan_filtering(struct dsa_sw
 		 * port and the corresponding CPU port is required the setup
 		 * for becoming a VLAN-aware port.
 		 */
+		int i;
+
 		mt7530_port_set_vlan_aware(ds, port);
-		mt7530_port_set_vlan_aware(ds, MT7530_CPU_PORT);
+		for (i = 0; i < MT7530_NUM_PORTS; i++)
+			if (dsa_is_cpu_port(ds, i))
+				mt7530_port_set_vlan_aware(ds, i);
 	} else {
 		pr_debug("%s:%d DSA  NOT vlan_filtering %d\n",__FUNCTION__,__LINE__,vlan_filtering);
 		mt7530_port_set_vlan_unaware(ds, port);
@@ -1683,9 +1702,10 @@ mt7530_hw_vlan_add(struct mt7530_priv *p
 {
 	u8 new_members;
 	u32 val;
+	int i;
 
 	new_members = entry->old_members | BIT(entry->port) |
-		      BIT(MT7530_CPU_PORT);
+		      dsa_cpu_ports(priv->ds);
 
 	/* Validate the entry with independent learning, create egress tag per
 	 * VLAN and joining the port as one of the port members.
@@ -1708,10 +1728,10 @@ mt7530_hw_vlan_add(struct mt7530_priv *p
 	 * that VLAN tags would be appended after hardware special tag used as
 	 * DSA tag.
 	 */
-	mt7530_rmw(priv, MT7530_VAWD2,
-		   ETAG_CTRL_P_MASK(MT7530_CPU_PORT),
-		   ETAG_CTRL_P(MT7530_CPU_PORT,
-			       MT7530_VLAN_EGRESS_STACK));
+	for (i = 0; i < MT7530_NUM_PORTS; i++)
+		if (dsa_is_cpu_port(priv->ds, i))
+			mt7530_rmw(priv, MT7530_VAWD2, ETAG_CTRL_P_MASK(i),
+				   ETAG_CTRL_P(i, MT7530_VLAN_EGRESS_STACK));
 }
 
 static void
@@ -1734,7 +1754,7 @@ mt7530_hw_vlan_del(struct mt7530_priv *p
 	 * the entry would be kept valid. Otherwise, the entry is got to be
 	 * disabled.
 	 */
-	if (new_members && new_members != BIT(MT7530_CPU_PORT)) {
+	if (new_members && new_members != dsa_cpu_ports(priv->ds)) {
 		val = IVL_MAC | VTAG_EN | PORT_MEM(new_members) |
 		      VLAN_VALID;
 		mt7530_write(priv, MT7530_VAWD1, val);
@@ -1952,6 +1972,16 @@ static void mt753x_port_mirror_del(struc
 	}
 }
 
+static int
+mt753x_port_change_cpu_port(struct dsa_switch *ds, int port,
+			    struct dsa_port *new_cpu_dp)
+{
+	mt7530_rmw(ds->priv, MT7530_PCR_P(port), PCR_MATRIX(dsa_cpu_ports(ds)),
+		   PCR_MATRIX(BIT(new_cpu_dp->index)));
+
+	return 0;
+}
+
 static enum dsa_tag_protocol
 mtk_get_tag_protocol(struct dsa_switch *ds, int port,
 		     enum dsa_tag_protocol mp)
@@ -3305,6 +3335,7 @@ static int mt753x_set_mac_eee(struct dsa
 }
 
 static const struct dsa_switch_ops mt7530_switch_ops = {
+	.port_change_cpu_port	= mt753x_port_change_cpu_port,
 	.get_tag_protocol	= mtk_get_tag_protocol,
 	.setup			= mt753x_setup,
 	.get_strings		= mt7530_get_strings,
@@ -3549,6 +3580,7 @@ mt7530_probe(struct mdio_device *mdiodev
 	priv->dev = &mdiodev->dev;
 	priv->ds->priv = priv;
 	priv->ds->ops = &mt7530_switch_ops;
+	//priv->ds->assisted_learning_on_cpu_port = true;
 	mutex_init(&priv->reg_mutex);
 	dev_set_drvdata(&mdiodev->dev, priv);
 	mutex_init(&priv->mib_lock);
