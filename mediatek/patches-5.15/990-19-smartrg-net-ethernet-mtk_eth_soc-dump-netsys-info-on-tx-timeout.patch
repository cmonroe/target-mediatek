--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
@@ -45,6 +45,7 @@ static const struct mtk_reg_map mtk_reg_
 	.tx_irq_mask		= 0x1a1c,
 	.tx_irq_status		= 0x1a18,
 	.pdma = {
+		.base_ptr	= 0x0800,
 		.rx_ptr		= 0x0900,
 		.rx_cnt_cfg	= 0x0904,
 		.pcrx_ptr	= 0x0908,
@@ -93,6 +94,7 @@ static const struct mtk_reg_map mt7628_r
 	.tx_irq_mask		= 0x0a28,
 	.tx_irq_status		= 0x0a20,
 	.pdma = {
+		.base_ptr	= 0x0800,
 		.rx_ptr		= 0x0900,
 		.rx_cnt_cfg	= 0x0904,
 		.pcrx_ptr	= 0x0908,
@@ -109,6 +111,7 @@ static const struct mtk_reg_map mt7986_r
 	.tx_irq_mask		= 0x461c,
 	.tx_irq_status		= 0x4618,
 	.pdma = {
+		.base_ptr	= 0x4000,
 		.rx_ptr		= 0x4100,
 		.rx_cnt_cfg	= 0x4104,
 		.pcrx_ptr	= 0x4108,
@@ -157,6 +160,7 @@ static const struct mtk_reg_map mt7988_r
 	.tx_irq_mask		= 0x461c,
 	.tx_irq_status		= 0x4618,
 	.pdma = {
+		.base_ptr	= 0x6800,
 		.rx_ptr		= 0x6900,
 		.rx_cnt_cfg	= 0x6904,
 		.pcrx_ptr	= 0x6908,
@@ -3271,14 +3275,61 @@ static bool mtk_hw_reset_check(struct mt
 	       (val & MTK_FE_INT_TSO_ALIGN) || (val & MTK_FE_INT_TSO_ILLEGAL);
 }
 
+static void mtk_dump_reg(void *_eth, char *name, u32 offset, u32 range)
+{
+	struct mtk_eth *eth = _eth;
+	u32 cur = offset;
+	pr_info("\n============ %s ============\n", name);
+	while(cur < offset + range) {
+		pr_info("0x%x: %08x %08x %08x %08x\n",
+			cur, mtk_r32(eth, cur), mtk_r32(eth, cur + 0x4),
+			mtk_r32(eth, cur + 0x8), mtk_r32(eth, cur + 0xc));
+		cur += 0x10;
+	}
+}
+static void mtk_dump_netsys_info(void *_eth)
+{
+	struct mtk_eth *eth = _eth;
+	const struct mtk_reg_map *reg_map = eth->soc->reg_map;
+	u32 id = 0;
+
+	mtk_dump_reg(eth, "FE", 0x0, 0x500);
+	mtk_dump_reg(eth, "ADMA", reg_map->pdma.base_ptr, 0x300);
+	for (id = 0; id < MTK_QDMA_PAGE_NUM; id++){
+		mtk_w32(eth, id, MTK_QDMA_PAGE(reg_map->qdma.qtx_cfg));
+		pr_info("\nQDMA PAGE:%x ",mtk_r32(eth, MTK_QDMA_PAGE(reg_map->qdma.qtx_cfg)));
+		mtk_dump_reg(eth, "QDMA", reg_map->qdma.qtx_cfg, 0x100);
+		mtk_w32(eth, 0, MTK_QDMA_PAGE(reg_map->qdma.qtx_cfg));
+	}
+	mtk_dump_reg(eth, "QDMA", reg_map->qdma.rx_ptr, 0x300);
+	mtk_dump_reg(eth, "WDMA", reg_map->wdma_base[0], 0x600);
+	mtk_dump_reg(eth, "PPE", 0x2200, 0x200);
+	mtk_dump_reg(eth, "GMAC", 0x10000, 0x300);
+	if (mtk_is_netsys_v3_or_greater(eth)) {
+		mtk_dump_reg(eth, "XGMAC0", 0x12000, 0x300);
+		mtk_dump_reg(eth, "XGMAC1", 0x13000, 0x300);
+		mtk_dump_usxgmii(eth->usxgmii_pcs[0]->regmap,
+			"USXGMII0", 0, 0x1000);
+		mtk_dump_usxgmii(eth->usxgmii_pcs[1]->regmap,
+			"USXGMII1", 0, 0x1000);
+	}
+}
+
 static void mtk_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
+	static int dump = 0;
 	struct mtk_mac *mac = netdev_priv(dev);
 	struct mtk_eth *eth = mac->hw;
 
 	if (test_bit(MTK_RESETTING, &eth->state))
 		return;
 
+	if (dump < 2) {
+		/* only do this twice */
+		mtk_dump_netsys_info(eth);
+		dump++;
+	}
+
 	if (!mtk_hw_reset_check(eth))
 		return;
 
@@ -5288,6 +5339,7 @@ static int mtk_probe(struct platform_dev
 	schedule_delayed_work(&eth->reset.monitor_work,
 			      MTK_DMA_MONITOR_TIMEOUT);
 
+	//mtk_dump_netsys_info(eth);
 	return 0;
 
 err_deinit_ppe:
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
@@ -27,6 +27,7 @@
 
 #define MTK_QDMA_NUM_QUEUES	16
 #define MTK_QDMA_PAGE_SIZE	2048
+#define MTK_QDMA_PAGE_NUM	8
 #define MTK_MAX_RX_LENGTH	1536
 #define MTK_MAX_RX_LENGTH_2K	2048
 #define MTK_TX_DMA_BUF_LEN	0x3fff
@@ -230,6 +231,9 @@
 #define MTK_RING_MAX_AGG_CNT_L		((MTK_HW_LRO_MAX_AGG_CNT & 0x3f) << 26)
 #define MTK_RING_MAX_AGG_CNT_H		((MTK_HW_LRO_MAX_AGG_CNT >> 6) & 0x3)
 
+/* QDMA Page Configuration Register */
+#define MTK_QDMA_PAGE(x)	(x + 0x1f0)
+
 /* QDMA TX Queue Configuration Registers */
 #define MTK_QTX_OFFSET		0x10
 #define QDMA_RES_THRES		4
@@ -1223,6 +1227,7 @@ struct mtk_reg_map {
 	u32	tx_irq_mask;
 	u32	tx_irq_status;
 	struct {
+		u32	base_ptr;	/* base pointer */
 		u32	rx_ptr;		/* rx base pointer */
 		u32	rx_cnt_cfg;	/* rx max count configuration */
 		u32	pcrx_ptr;	/* rx cpu pointer */
@@ -1692,10 +1697,16 @@ static inline int mtk_xgmii2mac_id(struc
 }
 
 #ifdef CONFIG_NET_MEDIATEK_SOC_USXGMII
+int mtk_dump_usxgmii(struct regmap *pmap, char *name, u32 offset, u32 range);
 struct phylink_pcs *mtk_sgmii_wrapper_select_pcs(struct mtk_eth *eth, int id);
 struct phylink_pcs *mtk_usxgmii_select_pcs(struct mtk_eth *eth, int id);
 int mtk_usxgmii_init(struct mtk_eth *eth);
 #else
+static inline int mtk_dump_usxgmii(struct regmap *pmap, char *name, u32 offset, u32 range)
+{
+	return 0;
+}
+
 static inline struct phylink_pcs *mtk_sgmii_wrapper_select_pcs(struct mtk_eth *eth, int id)
 {
 	return NULL;
--- a/drivers/net/ethernet/mediatek/mtk_usxgmii.c
+++ b/drivers/net/ethernet/mediatek/mtk_usxgmii.c
@@ -688,3 +688,22 @@ struct phylink_pcs *mtk_usxgmii_select_p
 
 	return &eth->usxgmii_pcs[xgmii_id]->pcs;
 }
+
+int mtk_dump_usxgmii(struct regmap *pmap, char *name, u32 offset, u32 range)
+{
+	unsigned int cur = offset;
+	unsigned int val1 = 0, val2 = 0, val3 = 0, val4 = 0;
+
+	pr_info("\n============ %s ============ pmap:%lx\n",
+		name, (unsigned long)pmap);
+	while (cur < offset + range) {
+		regmap_read(pmap, cur, &val1);
+		regmap_read(pmap, cur + 0x4, &val2);
+		regmap_read(pmap, cur + 0x8, &val3);
+		regmap_read(pmap, cur + 0xc, &val4);
+		pr_info("0x%x: %08x %08x %08x %08x\n", cur,
+			val1, val2, val3, val4);
+		cur += 0x10;
+	}
+	return 0;
+}
