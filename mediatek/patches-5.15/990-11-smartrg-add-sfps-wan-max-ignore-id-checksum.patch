--- a/drivers/net/phy/sfp.c
+++ b/drivers/net/phy/sfp.c
@@ -17,6 +17,8 @@
 #include <linux/rtnetlink.h>
 #include <linux/slab.h>
 #include <linux/workqueue.h>
+#include <linux/device.h>
+#include <linux/property.h>
 
 #include "sfp.h"
 #include "swphy.h"
@@ -338,20 +340,207 @@ static void sfp_fixup_halny_gsfp(struct
 	sfp->state_hw_mask &= ~(SFP_F_TX_FAULT | SFP_F_LOS);
 }
 
+static unsigned int sfp_devicetree_wan_speed(void)
+{
+    unsigned int mac_port_speed = 0;                            // init speed
+    printk("%s: SFP Searching device-tree for bound MAC/port interface speed\n", __FUNCTION__);
+    struct device_node *mac_port_node = NULL;          // init node pointer to search for bound mac/port device
+
+    // Search all nodes for first with property 'sfp'!=0, and property label='wan', and property 'phy-mode'!=0
+    while ( mac_port_node=of_find_node_with_property(mac_port_node, "sfp") )
+    {
+        u32 sfp_val = 0;
+        const char *sfp_phy_mode = NULL;
+        const char *sfp_label = NULL;
+        int phy_mode_speed = 0;
+
+        of_property_read_u32(mac_port_node, "sfp", &sfp_val);
+        if (sfp_val == 0) continue;                                             // If sfp property present and not zero continue search
+
+        of_property_read_string(mac_port_node, "label", &sfp_label);
+        if ( (sfp_label==NULL) || (strcmp(sfp_label, "wan")!=0) ) continue ;    // If node label property not 'wan' continue search
+
+        of_property_read_string(mac_port_node, "phy-mode", &sfp_phy_mode);
+        if (*sfp_phy_mode== NULL) continue;                                     // If no phy mode found continue search
+
+        // LTG for testing formats
+        //const char *test_txt = "10Gbase-x";
+        //sfp_phy_mode = test_txt;
+
+        // Search the phy_mode for a possible speed setting to clamp when no quirk found
+        if(strcmp(sfp_phy_mode, "sgmii")==0)
+        {
+            mac_port_speed = 1000;
+            printk("%s: SFP sfp=0x%04x, MAC/port label %s, phy_mode %s, speed %d max\n",
+                   __FUNCTION__, sfp_val, sfp_label, sfp_phy_mode, mac_port_speed );
+        }
+        else if(strcmp(sfp_phy_mode, "usxgmii")==0)
+        {
+            mac_port_speed = 10000;
+            printk("%s: SFP sfp=0x%04x, MAC/port label %s, phy_mode %s, speed %d max\n",
+                   __FUNCTION__, sfp_val, sfp_label, sfp_phy_mode, mac_port_speed );
+        }
+        else if (sscanf(sfp_phy_mode, "%d", &phy_mode_speed) == 1)
+        {
+            // Check if is was followed by G also, then multiply result by 1000 instead
+            // if (sscanf(sfp_phy_mode, "%dG", &phy_mode_speed) == 1) phy_mode_speed *= 1000;
+            if ((phy_mode_speed >= 120) && (phy_mode_speed < 1300))
+            {
+                mac_port_speed = 1000;
+            }
+            else if ((phy_mode_speed >= 1300) && (phy_mode_speed < 3200))
+            {
+                mac_port_speed = 2500;
+            }
+            else if ((phy_mode_speed >= 3200) && (phy_mode_speed < 6400))
+            {
+                mac_port_speed = 5000;
+            }
+            else if ((phy_mode_speed >= 6400) && (phy_mode_speed < 12800))
+            {
+                mac_port_speed = 10000;
+            }
+            else
+            {
+                mac_port_speed = 0;
+            }
+            printk("%s: SFP sfp=0x%04x, MAC/port label %s, phy_mode %s, speed mode extracted value %u max\n",
+                   __FUNCTION__, sfp_val, sfp_label, sfp_phy_mode, mac_port_speed );
+            of_node_put(mac_port_node);                                         // release ref count when done searching
+            break;
+        }
+        else
+        {
+            mac_port_speed = 0;
+            printk("%s: SFP sfp=0x%04x, MAC/port label %s, phy_mode %s, no max speed found!\n",
+                   __FUNCTION__, sfp_val, sfp_label, sfp_phy_mode);
+            of_node_put(mac_port_node);                                         // release ref count when done searching
+            break;
+        }
+    }
+    if (!mac_port_node)
+    {
+        printk("%s: SFP WAN no matching MAC/port interface found!\n",__FUNCTION__);
+    }
+
+    printk("%s: SFP WAN MAC/port interface speed returning %u max\n",__FUNCTION__, mac_port_speed);
+    return mac_port_speed;
+}
+
+static void sfp_quirk_max_wan(const struct sfp_eeprom_id *id,
+                                   unsigned long *modes)
+{
+    printk("%s SFP \n",__FUNCTION__);
+    printk("%s: SFP entry modes 0x%016lx\n",__FUNCTION__,*modes);
+    unsigned int dt_wan_speed = sfp_devicetree_wan_speed();
+
+    if (dt_wan_speed<=1000)
+    {
+        linkmode_zero(modes);
+        linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT, modes);
+    }
+    else if (dt_wan_speed<=2500)
+    {
+        linkmode_zero(modes);
+        linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT, modes);
+    }
+
+    printk("%s: SFP exit modes 0x%016lx\n",__FUNCTION__,*modes);
+}
+
+static void sfp_quirk_10000baset(const struct sfp_eeprom_id *id,
+				unsigned long *modes)
+{
+    printk("%s SFP \n",__FUNCTION__);
+    printk("%s: SFP entry modes 0x%016lx\n",__FUNCTION__,*modes);
+    linkmode_zero(modes);
+    linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT, modes);
+    printk("%s: SFP exit modes 0x%016lx\n",__FUNCTION__,*modes);
+}
+
+static void sfp_quirk_add_10000baset(const struct sfp_eeprom_id *id,
+				unsigned long *modes)
+{
+    printk("%s SFP \n",__FUNCTION__);
+    printk("%s: SFP entry modes 0x%016lx\n",__FUNCTION__,*modes);
+    linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT, modes);
+    printk("%s: SFP exit modes 0x%016lx\n",__FUNCTION__,*modes);
+}
+
 static void sfp_quirk_2500basex(const struct sfp_eeprom_id *id,
 				unsigned long *modes)
 {
-	linkmode_zero(modes);
-	linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT, modes);
-	printk("%s SFP \n",__FUNCTION__);
+    printk("%s SFP \n",__FUNCTION__);
+    printk("%s: SFP entry modes 0x%016lx\n",__FUNCTION__,*modes);
+    linkmode_zero(modes);
+    linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT, modes);
+    printk("%s: SFP exit modes 0x%016lx\n",__FUNCTION__,*modes);
+}
+
+static void sfp_quirk_add_2500basex(const struct sfp_eeprom_id *id,
+				unsigned long *modes)
+{
+    printk("%s SFP \n",__FUNCTION__);
+    printk("%s: SFP entry modes 0x%016lx\n",__FUNCTION__,*modes);
+    linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT, modes);
+    printk("%s: SFP exit modes 0x%016lx\n",__FUNCTION__,*modes);
+}
+
+static void sfp_quirk_2500baset(const struct sfp_eeprom_id *id,
+				unsigned long *modes)
+{
+    printk("%s SFP \n",__FUNCTION__);
+    printk("%s: SFP entry modes 0x%016lx\n",__FUNCTION__,*modes);
+    linkmode_zero(modes);
+    linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, modes);
+    printk("%s: SFP exit modes 0x%016lx\n",__FUNCTION__,*modes);
+}
+
+static void sfp_quirk_add_2500baset(const struct sfp_eeprom_id *id,
+				unsigned long *modes)
+{
+    printk("%s SFP \n",__FUNCTION__);
+    printk("%s: SFP entry modes 0x%016lx\n",__FUNCTION__,*modes);
+    linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, modes);
+    printk("%s: SFP extit modes 0x%016lx\n",__FUNCTION__,*modes);
 }
 
 static void sfp_quirk_1000basex(const struct sfp_eeprom_id *id,
 				unsigned long *modes)
 {
-	linkmode_zero(modes);
-	linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT, modes);
-	printk("%s SFP \n",__FUNCTION__);
+    printk("%s SFP \n",__FUNCTION__);
+    printk("%s: SFP entry modes 0x%016lx\n",__FUNCTION__,*modes);
+    linkmode_zero(modes);
+    linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT, modes);
+    printk("%s: SFP exit modes 0x%016lx\n",__FUNCTION__,*modes);
+}
+
+static void sfp_quirk_add_1000basex(const struct sfp_eeprom_id *id,
+				unsigned long *modes)
+{
+    printk("%s SFP \n",__FUNCTION__);
+    printk("%s: SFP entry modes 0x%016lx\n",__FUNCTION__,*modes);
+    linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT, modes);
+    printk("%s: SFP exit modes 0x%016lx\n",__FUNCTION__,*modes);
+}
+
+static void sfp_quirk_1000baset(const struct sfp_eeprom_id *id,
+				unsigned long *modes)
+{
+    printk("%s SFP \n",__FUNCTION__);
+    printk("%s: SFP entry modes 0x%016lx\n",__FUNCTION__,*modes);
+    linkmode_zero(modes);
+    linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, modes);
+    printk("%s: SFP exit modes 0x%016lx\n",__FUNCTION__,*modes);
+}
+
+static void sfp_quirk_add_1000baset(const struct sfp_eeprom_id *id,
+				unsigned long *modes)
+{
+    printk("%s SFP \n",__FUNCTION__);
+    printk("%s: SFP entry modes 0x%016lx\n",__FUNCTION__,*modes);
+    linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, modes);
+    printk("%s: SFP exit modes 0x%016lx\n",__FUNCTION__,*modes);
 }
 
 static void sfp_quirk_ubnt_uf_instant(const struct sfp_eeprom_id *id,
@@ -373,14 +562,30 @@ static void sfp_fixup_gpon_xxx(struct sf
 	printk("%s SFP \n",__FUNCTION__);
 }
 
+static void sfp_fixup_gpon_usepins(struct sfp *sfp)
+{
+	sfp->module_t_start_up = T_START_UP_BAD_GPON;
+	sfp->tx_fault_ignore = false;
+	sfp->state_hw_mask |= (SFP_F_TX_FAULT | SFP_F_LOS);
+	printk("%s SFP \n",__FUNCTION__);
+}
+
 static void sfp_fixup_copper_xxx(struct sfp *sfp)
 {
 	sfp->id.base.e1000_base_t=0;
 	printk("%s SFP \n",__FUNCTION__);
 }
 
+// ADTRAN Added a default quirk to use when unknown 10G devices found.
+static const struct sfp_quirk sfp_quirk_default_wan_max={
+		.vendor = "ADTRAN",
+		.part = "DEFAULT-WAN-MAX",
+		.modes = sfp_quirk_max_wan,
+		.fixup = NULL,
+};
+
 static const struct sfp_quirk sfp_quirks[] = {
-	{
+    {
 		// Alcatel Lucent G-010S-P can operate at 2500base-X, but
 		// incorrectly report 2500MBd NRZ in their EEPROM
 		// AKA Nokia from James Mouffat
@@ -434,36 +639,85 @@ static const struct sfp_quirk sfp_quirks
 		.part = "UF-INSTANT",
 		.modes = sfp_quirk_ubnt_uf_instant,
 	}, {
-		// F2
+		// F2 ADTRAN 1442535F2, ADTRAN SDX610 GPON ONT, 2.5G serdes
 		.vendor = "T&W",
 		.part = "TW2362H-CDEL-ADT",
 		.modes = sfp_quirk_2500basex,
 		.fixup = sfp_fixup_gpon_xxx,
 	}, {
-		// F3
+		// F3 ADTRAN 1442535F3 ADTRAN SDX610 GPON ONT, 1G serdes
 		.vendor = "T&W",
 		.part = "TW2362H-CDEL-AD1",
 		.fixup = sfp_fixup_gpon_xxx,
 	}, {
-		// 630
+		// 1287940F1 SDX630 10G XGS-PON
 		.vendor = "ADTRAN",
 		.part = "1287940F1",
-		.modes = sfp_quirk_2500basex,
+		.modes = sfp_quirk_max_wan,
+		//.modes = sfp_quirk_2500basex,
+		//.modes = sfp_quirk_add_2500basex,
+		//.modes = sfp_quirk_add_2500baset,
 		.fixup = sfp_fixup_gpon_xxx,
+		//.fixup = sfp_fixup_gpon_usepins,
 	}, {
-		// ADTRAN-1442300G1
+		// ADTRAN-1442300G1 RJ45 100 m Transmission Distance, 1 Gbps
 		.vendor = "LINKTEL",
 		.part = "LX1801INA-ADT",
 		.modes = sfp_quirk_1000basex,
 		.fixup = sfp_fixup_copper_xxx,
 	}, {
-		// FCLFB8521P2BTL-AR
+		// FCLFB8521P2BTL-AR RJ45 1000BASE-T Copper SFP Transceiver Module
 		.vendor = "FINISAR CORP.",
 		.part = "FCLF8521P2BTL-AR",
 		.modes = sfp_quirk_1000basex,
 		.fixup = sfp_fixup_copper_xxx,
+	}, {
+		// Fiberstore SFP 1G-LX-31 BiDi Transceiver operating at 1000base-X
+		.vendor = "FS",
+		.part = "SFP1G-LX-31",
+		.modes = sfp_quirk_1000basex,
+	}, {
+		// Fiberstore SFP 10GLR-31 BiDi Transceiver operating at 2500base-X
+		.vendor = "FS",
+		.part = "SFP-10GLR-31",
+		.modes = sfp_quirk_2500basex,
+	}, {
+		// Cogeco EPON SFP #1
+		.vendor = "CIGE",
+		.part = "XE-99S",
+        	.modes = sfp_quirk_max_wan,
+		//.modes = sfp_quirk_2500basex,
+		//.modes = sfp_quirk_add_2500basex,
+		//.modes = sfp_quirk_add_2500baset,
+        	.fixup = sfp_fixup_gpon_xxx,
+        	//.fixup = sfp_fixup_gpon_usepins,
+	}, {
+		// Cogeco EPON SFP #2  (Note This device was giving eeprom checksum error)
+        	.vendor = "Sercomm",
+		.part = "XES1010C",
+        	.modes = sfp_quirk_max_wan,
+        	//.modes = sfp_quirk_2500basex,
+        	//.modes = sfp_quirk_add_2500basex,
+        	//.modes = sfp_quirk_add_2500baset,
+        	.fixup = sfp_fixup_gpon_xxx,
+        	//.fixup = sfp_fixup_gpon_usepins,
+	}, {
+		// Adtran 1442110G1 SFP BiDi, 1.25G, 10Km (1490nm Tx/1310nm Rx), claims to support (RX_LOS, TX_FAULT, TX_DIS)
+        	.vendor = "WTD",
+		.part = "RTXM182-526S-ADT",
+		.modes = sfp_quirk_1000basex,
+	}, {
+		// Adtran 1442110G2 SFP BiDi, 1.25G, 10Km (1310nm Tx/1490nm Rx), claims to support (RX_LOS, TX_FAULT, TX_DIS)
+        	.vendor = "LINKTEL",
+		.part = "LX2101IDM-ADT",
+		.modes = sfp_quirk_1000basex,
+	}, {
+		// Adtran RTXL185-500-ADT, 10GBase-T Copper 30M, 64B/65B ENC
+        	.vendor = "WTD",
+		.part = "RTXL185-500-ADT",
+		.modes = sfp_quirk_max_wan,
+        	.fixup = sfp_fixup_copper_xxx,
 	}
-
 };
 
 static size_t sfp_strlen(const char *str, size_t maxlen)
@@ -498,6 +752,8 @@ static const struct sfp_quirk *sfp_looku
 	vs = sfp_strlen(id->base.vendor_name, ARRAY_SIZE(id->base.vendor_name));
 	ps = sfp_strlen(id->base.vendor_pn, ARRAY_SIZE(id->base.vendor_pn));
 
+	printk("%s: SFP vendor/part to look up vendor[%s] %d, part[%s] %d\n",__FUNCTION__, id->base.vendor_name, vs, id->base.vendor_pn, ps);
+
 	for (i = 0, q = sfp_quirks; i < ARRAY_SIZE(sfp_quirks); i++, q++)
 		if (sfp_match(q->vendor, id->base.vendor_name, vs) &&
 		    sfp_match(q->part, id->base.vendor_pn, ps))
@@ -2072,12 +2328,12 @@ static int sfp_sm_mod_probe(struct sfp *
 				 "EEPROM base structure checksum failure (0x%02x != 0x%02x)\n",
 				 check, id.base.cc_base);
 		} else {
-			dev_err(sfp->dev,
+			dev_warn(sfp->dev,
 				"EEPROM base structure checksum failure: 0x%02x != 0x%02x\n",
 				check, id.base.cc_base);
 			print_hex_dump(KERN_ERR, "sfp EE: ", DUMP_PREFIX_OFFSET,
 				       16, 1, &id, sizeof(id), true);
-			return -EINVAL;
+			//return -EINVAL;
 		}
 	}
 
@@ -2100,12 +2356,12 @@ static int sfp_sm_mod_probe(struct sfp *
 				 "EEPROM extended structure checksum failure (0x%02x != 0x%02x)\n",
 				 check, id.ext.cc_ext);
 		} else {
-			dev_err(sfp->dev,
+			dev_warn(sfp->dev,
 				"EEPROM extended structure checksum failure: 0x%02x != 0x%02x\n",
 				check, id.ext.cc_ext);
 			print_hex_dump(KERN_ERR, "sfp EE: ", DUMP_PREFIX_OFFSET,
 				       16, 1, &id, sizeof(id), true);
-			memset(&id.ext, 0, sizeof(id.ext));
+			//memset(&id.ext, 0, sizeof(id.ext));
 		}
 	}
 
@@ -2149,8 +2405,30 @@ static int sfp_sm_mod_probe(struct sfp *
 
 	sfp->tx_fault_ignore = false;
 
-	sfp->quirk = sfp_lookup_quirk(&id);
-	if (sfp->quirk && sfp->quirk->fixup)
+    sfp->quirk = sfp_lookup_quirk(&id);
+    if (sfp->quirk==NULL)
+    {
+        /* If no quirk handler found and nominal bit rate > 2.5G + 28%
+         * Modules supporting 2500BASE-X. Note that some
+         * modules use 2500Mbaud rather than 3100 or 3200Mbaud for
+         * 2500BASE-X, so we allow some slack here.
+         */
+        unsigned int nom_rate = id.base.br_nominal*100;
+        if(nom_rate>3200)
+        {
+            printk("%s: SFP vendor/part no quirk and br_nom>3200, setting default mode for max WAN\n",__FUNCTION__);
+            sfp->quirk = &sfp_quirk_default_wan_max;
+        }
+        else
+        {
+            printk("%s: SFP vendor/part no quirk and br_nom<=3200, no fixups or modes applied\n",__FUNCTION__);
+        }
+    }
+    else
+    {
+        printk("%s: SFP vendor/part found in quirk handlers - %s, %s applied\n",__FUNCTION__, sfp->quirk->vendor, sfp->quirk->part);
+    }
+    if (sfp->quirk && sfp->quirk->fixup)
 		sfp->quirk->fixup(sfp);
 
 	return 0;
