From 80e44de71773d2899adba559ec6a79b81d554991 Mon Sep 17 00:00:00 2001
From: developer <developer@mediatek.com>
Date: Thu, 9 Nov 2023 12:58:13 +0800
Subject: [PATCH] [][kernel][mt7988][pcie][Add WIFI HW reset flow]

[Description]
Add WIFI HW reset before PCIe host detects EP device for reboot.

[Release-log]
NA

Change-Id: I5bfad61d088c029d791747eb5fd40d118918a2f7
Reviewed-on: https://gerrit.mediatek.inc/c/openwrt/feeds/mtk_openwrt_feeds/+/8227163
---
 .../pci/controller/pcie-mediatek-gen3.c       | 36 +++++++++++++++++++
 1 file changed, 36 insertions(+)

--- a/drivers/pci/controller/pcie-mediatek-gen3.c
+++ b/drivers/pci/controller/pcie-mediatek-gen3.c
@@ -8,6 +8,8 @@
 
 #include <linux/clk.h>
 #include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
 #include <linux/iopoll.h>
 #include <linux/irq.h>
 #include <linux/irqchip/chained_irq.h>
@@ -15,6 +17,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/msi.h>
+#include <linux/of_gpio.h>
 #include <linux/pci.h>
 #include <linux/phy/phy.h>
 #include <linux/platform_device.h>
@@ -142,6 +145,9 @@ struct mtk_pcie_port {
 	struct clk_bulk_data *clks;
 	int num_clks;
 
+	struct gpio_desc *wifi_reset;
+	u32 wifi_reset_delay_ms;
+
 	int irq;
 	u32 saved_irq_state;
 	raw_spinlock_t irq_lock;
@@ -305,6 +311,12 @@ static int mtk_pcie_startup_port(struct
 	val |= PCIE_DISABLE_DVFSRC_VLT_REQ;
 	writel_relaxed(val, port->base + PCIE_MISC_CTRL_REG);
 
+	if (port->wifi_reset) {
+		gpiod_set_value_cansleep(port->wifi_reset, 0);
+		msleep(port->wifi_reset_delay_ms);
+		gpiod_set_value_cansleep(port->wifi_reset, 1);
+	}
+
 	/* Assert all reset signals */
 	val = readl_relaxed(port->base + PCIE_RST_CTRL_REG);
 	val |= PCIE_MAC_RSTB | PCIE_PHY_RSTB | PCIE_BRG_RSTB | PCIE_PE_RSTB;
@@ -731,6 +743,8 @@ static int mtk_pcie_parse_port(struct mt
 	struct device *dev = port->dev;
 	struct platform_device *pdev = to_platform_device(dev);
 	struct resource *regs;
+	enum of_gpio_flags flags;
+	enum gpiod_flags wifi_reset_init_flags;
 	int ret;
 
 	regs = platform_get_resource_byname(pdev, IORESOURCE_MEM, "pcie-mac");
@@ -777,6 +791,28 @@ static int mtk_pcie_parse_port(struct mt
 		return port->num_clks;
 	}
 
+	ret = of_get_named_gpio_flags(dev->of_node, "wifi-reset-gpios", 0,
+				      &flags);
+	if (ret >= 0) {
+		if (flags & OF_GPIO_ACTIVE_LOW)
+			wifi_reset_init_flags = GPIOD_OUT_HIGH;
+		else
+			wifi_reset_init_flags = GPIOD_OUT_LOW;
+		port->wifi_reset = devm_gpiod_get_optional(dev, "wifi-reset",
+							   wifi_reset_init_flags);
+		if (IS_ERR(port->wifi_reset)) {
+			ret = PTR_ERR(port->wifi_reset);
+			if (ret != -EPROBE_DEFER)
+				dev_err(dev,
+					"failed to request WIFI reset gpio\n");
+			return ret;
+		}
+		of_property_read_u32(dev->of_node, "wifi-reset-msleep",
+				     &port->wifi_reset_delay_ms);
+	} else if (ret == -EPROBE_DEFER) {
+		return ret;
+	}
+
 	return 0;
 }
 
