Index: linux-5.15.104/drivers/net/phy/mxl-gpy.c
===================================================================
--- linux-5.15.104.orig/drivers/net/phy/mxl-gpy.c
+++ linux-5.15.104/drivers/net/phy/mxl-gpy.c
@@ -70,6 +70,7 @@
 #define VSPEC1_SGMII_CTRL_ANRS	BIT(9)		/* Restart Aneg */
 #define VSPEC1_SGMII_ANEN_ANRS	(VSPEC1_SGMII_CTRL_ANEN | \
 				 VSPEC1_SGMII_CTRL_ANRS)
+#define VSPEC1_SGMII_CTRL_FIXED_2G5	BIT(5)	/* Fixed SGMII speed */
 
 /* WoL */
 #define VPSPEC2_WOL_CTL		0x0E06
@@ -112,6 +113,35 @@ static int gpy_led_write(struct phy_devi
 	return 0;
 }
 
+static int gpy_of_init(struct phy_device *phydev)
+{
+	int ret = 0;
+	struct device *dev = &phydev->mdio.dev;
+	struct device_node *of_node = dev->of_node;
+
+	if (!of_node) {
+		phydev_info(phydev, "failed to get of_node, ignoring OF config\n");
+		return 0;
+	}
+
+	if (of_property_read_bool(of_node, "mxl,sgmii-fixed")) {
+		ret = phy_modify_mmd(phydev, MDIO_MMD_VEND1, VSPEC1_SGMII_CTRL,
+				VSPEC1_SGMII_CTRL_FIXED_2G5, 1);
+
+		if (ret < 0)
+			return ret;
+	}
+
+	if (of_property_read_bool(of_node, "mxl,led-drive-vdd")) {
+		ret = phy_write(phydev, PHY_LED, 0x0f00);
+
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
 static int gpy_config_init(struct phy_device *phydev)
 {
 	int ret;
@@ -132,7 +162,20 @@ static int gpy_config_init(struct phy_de
 	if (ret < 0)
 		return ret;
 
-	return gpy_led_write(phydev);
+	ret = gpy_led_write(phydev);
+	if (ret < 0)
+		return ret;
+
+	/**
+	 * disable rate adaptation to handle upgrade case for platforms
+	 * which don't perform a PHY reset on warm reboot like the 854
+	 */
+	ret = phy_modify_mmd(phydev, MDIO_MMD_VEND1, VSPEC1_SGMII_CTRL,
+			VSPEC1_SGMII_CTRL_FIXED_2G5, 0);
+	if (ret < 0)
+		return ret;
+
+	return gpy_of_init(phydev);
 }
 
 static int gpy_probe(struct phy_device *phydev)
