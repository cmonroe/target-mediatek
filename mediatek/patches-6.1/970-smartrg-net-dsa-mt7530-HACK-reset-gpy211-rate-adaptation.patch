From: Chad Monroe <chad@monroe.io>
Date: Mon, 08 May 2023 22:11:50 -0700
Subject: [PATCH] net: dsa: mt7530: reset GPY211 rate adaptation 

If upgrading from a build with rate adaptation enabled on the GPY211 to one
with it disabled, the phy can get stuck in a broken state on platforms which
don't have a working phy reset line. In the case of SmartOS, the only target
this affects is the 854 where the GPY211 is connected to MT7531 port 5. The
only way to detect this condition is presence of RX errors but no RX packets.

If the failure condition is detected it can usually be cleared by toggling the
rate adaptation bit once or in some very rare cases twice.

Signed-off-by: Chad Monroe <chad@monroe.io>
---
 drivers/net/dsa/mt7530.c |   92 +++++++++++++++++++++++++++++++++++++
 1 file changed, 92 insertions(+)

--- a/drivers/net/dsa/mt7530.c
+++ b/drivers/net/dsa/mt7530.c
@@ -856,6 +856,92 @@ mt7530_get_ethtool_stats(struct dsa_swit
 }
 
 static void
+mt7531_mxl_gpy_fixup(struct mt7530_priv *priv)
+{
+	int ret;
+	struct device *dev = priv->dev;
+
+	ret = mt7531_ind_c45_phy_read(priv, 5, 0x1e, 0x8);
+	if (ret < 0) {
+		dev_err(dev, "failed to read VSPEC1_SGMII_CTRL for port 5, cause: %d\n", ret);
+		return;
+	}
+	
+	dev_info(dev, "read port 5 VSPEC1_SGMII_CTRL=%04x\n", ret);
+
+	/**
+	 * bit 5: SGMII rate adaptation enable
+	 * bit 9: SGMII trigger autonegotiation
+	 * bit 12: SGMII autonegotiation enable
+	 */
+	ret |= (1 << 5);
+	ret |= (1 << 9);
+	ret |= (1 << 12);
+
+	dev_info(dev, "writing port 5 VSPEC1_SGMII_CTRL=%04x\n", ret);
+	if (mt7531_ind_c45_phy_write(priv, 5, 0x1e, 0x8, ret) < 0)
+		dev_err(dev, "failed writing port 5 VSPEC1_SGMII_CTRL=%04x\n", ret);
+	msleep(100);
+
+	/**
+	 * disable SGMII rate adaptation
+	 **/
+	ret = mt7531_ind_c45_phy_read(priv, 5, 0x1e, 0x8);
+	if (ret < 0) {
+		dev_err(dev, "failed to read VSPEC1_SGMII_CTRL for port 5, cause: %d\n", ret);
+		return;
+	} else {
+		dev_info(dev, "read port 5 VSPEC1_SGMII_CTRL=%04x\n", ret);
+	}
+	
+	ret &= ~(1 << 5);
+
+	dev_info(dev, "writing port 5 VSPEC1_SGMII_CTRL=%04x\n", ret);
+	if (mt7531_ind_c45_phy_write(priv, 5, 0x1e, 0x8, ret) < 0)
+		dev_err(dev, "failed writing port 5 VSPEC1_SGMII_CTRL=%04x\n", ret);
+
+	dev_err(dev, "WARNING!! attempted to correct bad GPY state.\n");
+}
+
+static void
+mt7531_mxl_gpy_check(struct mt7530_priv *priv, struct rtnl_link_stats64 *stats)
+{
+	struct device *dev = priv->dev;
+	static int do_gpy_check = 0;
+	static int dts_check_done = 0;
+	static int gpy_check_count = 10;
+
+	if (gpy_check_count++ <= 10) {
+		return;
+	} else {
+		gpy_check_count = 0;
+	}
+
+	if (!dts_check_done) {
+		if (of_property_read_bool(dsa_to_port(priv->ds, 5)->dn, "smartrg,fixed-phy-upgrade-hack")) {
+			dev_info(priv->dev, "enable fixed phy upgrade hack\n");
+			do_gpy_check = 1;
+		}
+		dts_check_done = 1;
+	}
+
+	if (do_gpy_check) {
+
+		if (stats->rx_packets > 10) {
+			dev_info(priv->dev, "GPY check done, looks OK\n");
+			do_gpy_check = 0;
+		} else {
+			if ((stats->rx_errors > 5) || (stats->rx_crc_errors > 5)) {
+				dev_info(dev, "stats->rx_errors=%llu stats->rx_crc_errors=%llu stats->rx_packets=%llu\n",
+						stats->rx_errors, stats->rx_crc_errors, stats->rx_packets);
+
+				mt7531_mxl_gpy_fixup(priv);
+			}
+		}
+	}
+}
+
+static void
 mt7530_mib_fetch_port_stat(struct mt7530_priv *priv, int port)
 {
 	u32 reg, i;
@@ -930,6 +1016,10 @@ mt7530_mib_fetch_port_stat(struct mt7530
 				break;
 		}
 	}
+
+	if ((port == 5) && mt7531_dual_sgmii_supported(priv)) {
+		mt7531_mxl_gpy_check(priv, storage);
+	}
 }
 
 static int mib_work_delay=MT7530_MIB_WORK_DELAY;
