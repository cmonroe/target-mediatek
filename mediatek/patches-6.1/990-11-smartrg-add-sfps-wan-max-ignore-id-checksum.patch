--- a/drivers/net/phy/sfp.c
+++ b/drivers/net/phy/sfp.c
@@ -17,6 +17,8 @@
 #include <linux/rtnetlink.h>
 #include <linux/slab.h>
 #include <linux/workqueue.h>
+#include <linux/device.h>
+#include <linux/property.h>
 
 #include "sfp.h"
 #include "swphy.h"
@@ -360,10 +362,140 @@ static void sfp_fixup_rollball_cc(struct
 	sfp->id.base.extended_cc = SFF8024_ECC_10GBASE_T_SFI;
 }
 
+static unsigned int sfp_devicetree_wan_speed(void)
+{
+	unsigned int mac_port_speed = 0;                            // init speed
+	printk("%s: SFP Searching device-tree for bound MAC/port interface speed\n", __FUNCTION__);
+	struct device_node *mac_port_node = NULL;          // init node pointer to search for bound mac/port device
+
+	// Search all nodes for first with property 'sfp'!=0, and property label='wan', and property 'phy-mode'!=0
+	while ( mac_port_node=of_find_node_with_property(mac_port_node, "sfp") )
+	{
+		u32 sfp_val = 0;
+		const char *sfp_phy_mode = NULL;
+		const char *sfp_label = NULL;
+		int phy_mode_speed = 0;
+
+		of_property_read_u32(mac_port_node, "sfp", &sfp_val);
+		if (sfp_val == 0) continue;                                             // If sfp property present and not zero continue search
+
+		of_property_read_string(mac_port_node, "label", &sfp_label);
+		if ( (sfp_label==NULL) || (strcmp(sfp_label, "wan")!=0) ) continue ;    // If node label property not 'wan' continue search
+
+		of_property_read_string(mac_port_node, "phy-mode", &sfp_phy_mode);
+		if (*sfp_phy_mode== NULL) continue;                                     // If no phy mode found continue search
+
+		// LTG for testing formats
+		//const char *test_txt = "10Gbase-x";
+		//sfp_phy_mode = test_txt;
+
+		// Search the phy_mode for a possible speed setting to clamp when no quirk found
+		if(strcmp(sfp_phy_mode, "sgmii")==0)
+		{
+			mac_port_speed = 1000;
+			printk("%s: SFP sfp=0x%04x, MAC/port label %s, phy_mode %s, speed %d max\n",
+					__FUNCTION__, sfp_val, sfp_label, sfp_phy_mode, mac_port_speed );
+		}
+		else if(strcmp(sfp_phy_mode, "usxgmii")==0)
+		{
+			mac_port_speed = 10000;
+			printk("%s: SFP sfp=0x%04x, MAC/port label %s, phy_mode %s, speed %d max\n",
+					__FUNCTION__, sfp_val, sfp_label, sfp_phy_mode, mac_port_speed );
+		}
+		else if (sscanf(sfp_phy_mode, "%d", &phy_mode_speed) == 1)
+		{
+			// Check if is was followed by G also, then multiply result by 1000 instead
+			// if (sscanf(sfp_phy_mode, "%dG", &phy_mode_speed) == 1) phy_mode_speed *= 1000;
+			if ((phy_mode_speed >= 120) && (phy_mode_speed < 1300))
+			{
+				mac_port_speed = 1000;
+			}
+			else if ((phy_mode_speed >= 1300) && (phy_mode_speed < 3200))
+			{
+				mac_port_speed = 2500;
+			}
+			else if ((phy_mode_speed >= 3200) && (phy_mode_speed < 6400))
+			{
+				mac_port_speed = 5000;
+			}
+			else if ((phy_mode_speed >= 6400) && (phy_mode_speed < 12800))
+			{
+				mac_port_speed = 10000;
+			}
+			else
+			{
+				mac_port_speed = 0;
+			}
+
+			printk("%s: SFP sfp=0x%04x, MAC/port label %s, phy_mode %s, speed mode extracted value %u max\n",
+					__FUNCTION__, sfp_val, sfp_label, sfp_phy_mode, mac_port_speed );
+			of_node_put(mac_port_node);                                         // release ref count when done searching
+			break;
+		}
+		else
+		{
+			mac_port_speed = 0;
+			printk("%s: SFP sfp=0x%04x, MAC/port label %s, phy_mode %s, no max speed found!\n",
+					__FUNCTION__, sfp_val, sfp_label, sfp_phy_mode);
+			of_node_put(mac_port_node);                                         // release ref count when done searching
+			break;
+		}
+	}
+	if (!mac_port_node)
+	{
+		printk("%s: SFP WAN no matching MAC/port interface found!\n",__FUNCTION__);
+	}
+
+	printk("%s: SFP WAN MAC/port interface speed returning %u max\n",__FUNCTION__, mac_port_speed);
+	return mac_port_speed;
+}
+
+static void sfp_quirk_max_wan(const struct sfp_eeprom_id *id,
+				unsigned long *modes, unsigned long *interfaces)
+{
+	printk("%s SFP \n",__FUNCTION__);
+	printk("%s: SFP entry modes 0x%016lx\n",__FUNCTION__,*modes);
+	unsigned int dt_wan_speed = sfp_devicetree_wan_speed();
+
+	if (dt_wan_speed<=1000)
+	{
+		linkmode_zero(modes);
+		linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT, modes);
+	}
+	else if (dt_wan_speed<=2500)
+	{
+		linkmode_zero(modes);
+		linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT, modes);
+	}
+
+	printk("%s: SFP exit modes 0x%016lx\n",__FUNCTION__,*modes);
+}
+
+static void sfp_quirk_10000baset(const struct sfp_eeprom_id *id,
+				unsigned long *modes)
+{
+	printk("%s SFP \n",__FUNCTION__);
+	printk("%s: SFP entry modes 0x%016lx\n",__FUNCTION__,*modes);
+	linkmode_zero(modes);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT, modes);
+	printk("%s: SFP exit modes 0x%016lx\n",__FUNCTION__,*modes);
+}
+
+static void sfp_quirk_add_10000baset(const struct sfp_eeprom_id *id,
+				unsigned long *modes)
+{
+	printk("%s SFP \n",__FUNCTION__);
+	printk("%s: SFP entry modes 0x%016lx\n",__FUNCTION__,*modes);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT, modes);
+	printk("%s: SFP exit modes 0x%016lx\n",__FUNCTION__,*modes);
+}
+
 static void sfp_quirk_2500basex(const struct sfp_eeprom_id *id,
 				unsigned long *modes,
 				unsigned long *interfaces)
 {
+	printk("%s SFP \n",__FUNCTION__);
+	printk("%s: SFP entry modes 0x%016lx\n",__FUNCTION__,*modes);
 	linkmode_zero(modes);
 	linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT, modes);
 	__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);
@@ -374,11 +506,41 @@ static void sfp_quirk_1000basex(const st
 				unsigned long *modes,
 				unsigned long *interfaces)
 {
+	printk("%s SFP \n",__FUNCTION__);
+	printk("%s: SFP entry modes 0x%016lx\n",__FUNCTION__,*modes);
 	linkmode_zero(modes);
 	linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT, modes);
 	printk("%s SFP \n",__FUNCTION__);
 }
 
+static void sfp_quirk_add_1000basex(const struct sfp_eeprom_id *id,
+				unsigned long *modes)
+{
+	printk("%s SFP \n",__FUNCTION__);
+	printk("%s: SFP entry modes 0x%016lx\n",__FUNCTION__,*modes);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT, modes);
+	printk("%s: SFP exit modes 0x%016lx\n",__FUNCTION__,*modes);
+}
+
+static void sfp_quirk_1000baset(const struct sfp_eeprom_id *id,
+				unsigned long *modes)
+{
+	printk("%s SFP \n",__FUNCTION__);
+	printk("%s: SFP entry modes 0x%016lx\n",__FUNCTION__,*modes);
+	linkmode_zero(modes);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, modes);
+	printk("%s: SFP exit modes 0x%016lx\n",__FUNCTION__,*modes);
+}
+
+static void sfp_quirk_add_1000baset(const struct sfp_eeprom_id *id,
+				unsigned long *modes)
+{
+	printk("%s SFP \n",__FUNCTION__);
+	printk("%s: SFP entry modes 0x%016lx\n",__FUNCTION__,*modes);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, modes);
+	printk("%s: SFP exit modes 0x%016lx\n",__FUNCTION__,*modes);
+}
+
 static void sfp_quirk_ubnt_uf_instant(const struct sfp_eeprom_id *id,
 				      unsigned long *modes,
 				      unsigned long *interfaces)
@@ -399,12 +561,28 @@ static void sfp_fixup_gpon_xxx(struct sf
 	printk("%s SFP \n",__FUNCTION__);
 }
 
+static void sfp_fixup_gpon_usepins(struct sfp *sfp)
+{
+	sfp->module_t_start_up = T_START_UP_BAD_GPON;
+	sfp->tx_fault_ignore = false;
+	sfp->state_hw_mask |= (SFP_F_TX_FAULT | SFP_F_LOS);
+	printk("%s SFP \n",__FUNCTION__);
+}
+
 static void sfp_fixup_copper_xxx(struct sfp *sfp)
 {
 	sfp->id.base.e1000_base_t=0;
 	printk("%s SFP \n",__FUNCTION__);
 }
 
+// ADTRAN Added a default quirk to use when unknown 10G devices found.
+static const struct sfp_quirk sfp_quirk_default_wan_max={
+	.vendor = "ADTRAN",
+	.part = "DEFAULT-WAN-MAX",
+	.modes = sfp_quirk_max_wan,
+	.fixup = NULL,
+};
+
 #define SFP_QUIRK(_v, _p, _m, _f) \
 	{ .vendor = _v, .part = _p, .modes = _m, .fixup = _f, }
 #define SFP_QUIRK_M(_v, _p, _m) SFP_QUIRK(_v, _p, _m, NULL)
@@ -441,20 +619,39 @@ static const struct sfp_quirk sfp_quirks
 	// OEM SFP-GE-T is 1000Base-T module
 	SFP_QUIRK_F("OEM", "SFP-GE-T", sfp_fixup_ignore_tx_fault),
 
-	// Adtran F2
+	// Adtran F2 1442535F2, ADTRAN SDX610 GPON ONT, 2.5G serdes
 	SFP_QUIRK("T&W", "TW2362H-CDEL-ADT", sfp_quirk_2500basex,
 		  sfp_fixup_gpon_xxx),
-	// Adtran F3
+	// Adtran F3 1442535F3 ADTRAN SDX610 GPON ONT, 1G serdes
 	SFP_QUIRK_M("T&W", "TW2362H-CDEL-AD1", sfp_quirk_2500basex),
-	// Adtran SDX-630
-	SFP_QUIRK("ADTRAN", "1287940F1", sfp_quirk_2500basex,
+	// Adtran SDX-630 1287940F1 SDX630 10G XGS-PON
+	SFP_QUIRK("ADTRAN", "1287940F1", sfp_quirk_max_wan,
 		  sfp_fixup_gpon_xxx),
-	// Adtran 1442300G1
+	// Adtran 1442300G1 RJ45 100 m Transmission Distance, 1 Gbps
 	SFP_QUIRK("LINKTEL", "LX1801INA-ADT", sfp_quirk_1000basex,
 		  sfp_fixup_copper_xxx),
-	// FCLFB8521P2BTL-AR
+	// Adtran 1442110G1 SFP BiDi, 1.25G, 10Km (1490nm Tx/1310nm Rx), claims to support (RX_LOS, TX_FAULT, TX_DIS)
+	SFP_QUIRK_M("WTD", "RTXM182-526S-ADT", sfp_quirk_1000basex),
+	// Adtran 1442110G2 SFP BiDi, 1.25G, 10Km (1310nm Tx/1490nm Rx), claims to support (RX_LOS, TX_FAULT, TX_DIS)
+	SFP_QUIRK_M("LINKTEL", "LX2101IDM-ADT", sfp_quirk_1000basex),
+	// Adtran RTXL185-500-ADT, 10GBase-T Copper 30M, 64B/65B ENC
+	SFP_QUIRK("WTD", "RTXL185-500-ADT", sfp_quirk_max_wan,
+		  sfp_fixup_copper_xxx),
+
+	// Cogeco EPON SFP #1
+	SFP_QUIRK("CIGE", "XE-99S", sfp_quirk_max_wan,
+		  sfp_fixup_gpon_xxx),
+	// Cogeco EPON SFP #2  (Note This device was giving eeprom checksum error)
+	SFP_QUIRK("Sercomm", "XES1010C", sfp_quirk_max_wan,
+		  sfp_fixup_gpon_xxx),
+
+	// FCLFB8521P2BTL-AR RJ45 1000BASE-T Copper SFP Transceiver Module
 	SFP_QUIRK("FINISAR CORP.", "FCLF8521P2BTL-AR", sfp_quirk_1000basex,
 		  sfp_fixup_copper_xxx),
+	// Fiberstore SFP 1G-LX-31 BiDi Transceiver operating at 1000base-X
+	SFP_QUIRK_M("FS", "SFP1G-LX-31", sfp_quirk_1000basex),
+	// Fiberstore SFP 10GLR-31 BiDi Transceiver operating at 2500base-X
+	SFP_QUIRK_M("FS", "SFP-10GLR-31", sfp_quirk_2500basex),
 
 	// Lantech 8330-262D-E can operate at 2500base-X, but incorrectly report
 	// 2500MBd NRZ in their EEPROM
@@ -501,6 +698,8 @@ static const struct sfp_quirk *sfp_looku
 	vs = sfp_strlen(id->base.vendor_name, ARRAY_SIZE(id->base.vendor_name));
 	ps = sfp_strlen(id->base.vendor_pn, ARRAY_SIZE(id->base.vendor_pn));
 
+	printk("%s: SFP vendor/part to look up vendor[%s] %d, part[%s] %d\n",__FUNCTION__, id->base.vendor_name, vs, id->base.vendor_pn, ps);
+
 	for (i = 0, q = sfp_quirks; i < ARRAY_SIZE(sfp_quirks); i++, q++)
 		if (sfp_match(q->vendor, id->base.vendor_name, vs) &&
 		    sfp_match(q->part, id->base.vendor_pn, ps))
@@ -2059,12 +2258,12 @@ static int sfp_sm_mod_probe(struct sfp *
 				 "EEPROM base structure checksum failure (0x%02x != 0x%02x)\n",
 				 check, id.base.cc_base);
 		} else {
-			dev_err(sfp->dev,
+			dev_warn(sfp->dev,
 				"EEPROM base structure checksum failure: 0x%02x != 0x%02x\n",
 				check, id.base.cc_base);
 			print_hex_dump(KERN_ERR, "sfp EE: ", DUMP_PREFIX_OFFSET,
 				       16, 1, &id, sizeof(id), true);
-			return -EINVAL;
+			//return -EINVAL;
 		}
 	}
 
@@ -2088,12 +2287,12 @@ static int sfp_sm_mod_probe(struct sfp *
 				 "EEPROM extended structure checksum failure (0x%02x != 0x%02x)\n",
 				 check, id.ext.cc_ext);
 		} else {
-			dev_err(sfp->dev,
+			dev_warn(sfp->dev,
 				"EEPROM extended structure checksum failure: 0x%02x != 0x%02x\n",
 				check, id.ext.cc_ext);
 			print_hex_dump(KERN_ERR, "sfp EE: ", DUMP_PREFIX_OFFSET,
 				       16, 1, &id, sizeof(id), true);
-			memset(&id.ext, 0, sizeof(id.ext));
+			//memset(&id.ext, 0, sizeof(id.ext));
 		}
 	}
 
@@ -2149,6 +2348,29 @@ static int sfp_sm_mod_probe(struct sfp *
 		sfp->mdio_protocol = MDIO_I2C_NONE;
 
 	sfp->quirk = sfp_lookup_quirk(&id);
+	if (sfp->quirk==NULL)
+	{
+		/* If no quirk handler found and nominal bit rate > 2.5G + 28%
+		 * Modules supporting 2500BASE-X. Note that some
+		 * modules use 2500Mbaud rather than 3100 or 3200Mbaud for
+		 * 2500BASE-X, so we allow some slack here.
+		 */
+		unsigned int nom_rate = id.base.br_nominal*100;
+		if(nom_rate>3200)
+		{
+			printk("%s: SFP vendor/part no quirk and br_nom>3200, setting default mode for max WAN\n",__FUNCTION__);
+			sfp->quirk = &sfp_quirk_default_wan_max;
+		}
+		else
+		{
+			printk("%s: SFP vendor/part no quirk and br_nom<=3200, no fixups or modes applied\n",__FUNCTION__);
+		}
+	}
+	else
+	{
+		printk("%s: SFP vendor/part found in quirk handlers - %s, %s applied\n",__FUNCTION__, sfp->quirk->vendor, sfp->quirk->part);
+	}
+
 	if (sfp->quirk && sfp->quirk->fixup)
 		sfp->quirk->fixup(sfp);
 
